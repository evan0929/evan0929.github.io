<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OkHttp原理解析</title>
      <link href="/posts/ff8004af/"/>
      <url>/posts/ff8004af/</url>
      
        <content type="html"><![CDATA[<h1 id="OkHttp原理解析"><a href="#OkHttp原理解析" class="headerlink" title="OkHttp原理解析"></a>OkHttp原理解析</h1><p>在上一篇文章我们讲解了OkHttp的简单使用，本篇文章根据源码来看下OkHttp是怎么来工作的。</p><h2 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h2><p>OkHttpClient对象是我们请求的客户端，是使用okhttp的第一步，上节也说了，他有两种生成的方法：</p><ol><li>new</li><li>builder</li></ol><p>方法1最终也是调用的builder的方法来生成</p><pre><code class="java">public OkHttpClient() &#123;  this(new Builder());&#125;</code></pre><p>那么我们需要看的就是new Builder()方法干了什么就可以了（这里就不贴源码），我们可以看到的是它其实就是初始化一些参数，比如：</p><pre><code class="java">dispatcher：调度器proxy：代理interceptors：拦截器cookieJar：cookiecache：缓存socketFactory：socket工厂类isTLS：是否使用TLS协议connectionPool：连接池以及一些超时设置</code></pre><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p>这个类就是请求数据的封装类，主要包含以下参数：</p><pre><code>urlmethod（get post）headers 请求头body 请求bodytags 请求tag</code></pre><h2 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h2><p>发送请求类，这个类其实就是封装我们对于请求的一些操作的接口：</p><ol><li>加载请求</li><li>请求</li><li>取消请求</li><li>请求状态</li><li>超时</li></ol><h2 id="call-execute-enqueue"><a href="#call-execute-enqueue" class="headerlink" title="call.execute()/enqueue()"></a>call.execute()/enqueue()</h2><p>这个方法才是我们发送一个请求的开始</p><h2 id="newCall"><a href="#newCall" class="headerlink" title="newCall()"></a>newCall()</h2><p>这里是我们调用请求要走的方法，它调用了RealCall.newRealCall()方法。这里才是真正的调用。我们来具体实现过程。</p><p>这里的RealCall继承了Call。所以我们直接来看它的execute()/enqueue()的重写方法。</p><p>看到具体都是调用client.dispatcher().enqueue（）/client.dispatcher().executed(this);</p><p>这里的client.dispatcher就是okhttp的一个任务调度器，来进行管理请求的具体调度。</p><p>这里就要说到Okhttp的双队列机制：</p><pre><code class="java">readyAsyncCalls.add(call);//添加到runnablepromoteAndExecute();//双队列</code></pre><p>这里我们贴下源码：</p><pre><code class="java">private boolean promoteAndExecute() &#123;  assert (!Thread.holdsLock(this));  List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;();  boolean isRunning;  synchronized (this) &#123;    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;      AsyncCall asyncCall = i.next();      if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity.      if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; // Host max capacity.      i.remove();      asyncCall.callsPerHost().incrementAndGet();      executableCalls.add(asyncCall);      runningAsyncCalls.add(asyncCall);    &#125;    isRunning = runningCallsCount() &gt; 0;  &#125;  for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123;    AsyncCall asyncCall = executableCalls.get(i);    asyncCall.executeOn(executorService());  &#125;  return isRunning;&#125;</code></pre><p>这里我们能看到：</p><ol><li>判断是否超出最大请求数（maxRequests）</li><li>判断是否大于host主机的最大请求数（maxRequestsPerHost）</li><li>放入一个临时的队列（executableCalls.add()）</li><li>放入正在执行的队列（runningAsyncCalls.add()）</li><li>执行executeOn()方法</li></ol><p>我们再来看下executeOn()：</p><p>首先它asyncCall.executeOn(executorService());调用了executorService()方法：</p><pre><code class="java">public synchronized ExecutorService executorService() &#123;  if (executorService == null) &#123;    executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,        new SynchronousQueue&lt;&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));  &#125;  return executorService;&#125;</code></pre><p>这里我们就看到调用了线程池来进行实现。</p><blockquote><ol><li>无核心线程的线程池</li><li>线程池无限大</li><li>立即执行</li><li>60s的存活时间</li><li>new SynchronousQueue&lt;&gt;()具体是啥忘了</li></ol></blockquote><p>我们再来看下executeOn方法具体干了什么？</p><pre><code class="java">void executeOn(ExecutorService executorService) &#123;  assert (!Thread.holdsLock(client.dispatcher()));  boolean success = false;  try &#123;    executorService.execute(this);    success = true;  &#125; catch (RejectedExecutionException e) &#123;    InterruptedIOException ioException = new InterruptedIOException(&quot;executor rejected&quot;);    ioException.initCause(e);    transmitter.noMoreExchanges(ioException);    responseCallback.onFailure(RealCall.this, ioException);  &#125; finally &#123;    if (!success) &#123;      client.dispatcher().finished(this); // This call is no longer running!    &#125;  &#125;&#125;</code></pre><p>executeOn执行了线程池的execute的方法，而线程池的execute执行方法Runnable的run方法，而run方法去执行的是重写的execute()方法。总结下来就是executeOn其实就是做了一件事，就是将请求丢到线程池。</p><p>这里的AsyncCall继承一个NamedRunnable，而NamedRunnable继承Runnable。这里就是生成一个线程来做处理。</p><p>在NamedRunnable的run()方法里面调用execute()方法，我们接下来需要看的就是execute()方法。</p><pre><code class="java">Response response = getResponseWithInterceptorChain();</code></pre><p>就返回了响应数据类response，那么主要执行的方法就是getResponseWithInterceptorChain()方法</p><p>这里我们贴下源码：</p><pre><code class="java">Response getResponseWithInterceptorChain() throws IOException &#123;  // Build a full stack of interceptors.  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();  interceptors.addAll(client.interceptors());  interceptors.add(new RetryAndFollowUpInterceptor(client));  interceptors.add(new BridgeInterceptor(client.cookieJar()));  interceptors.add(new CacheInterceptor(client.internalCache()));  interceptors.add(new ConnectInterceptor(client));  if (!forWebSocket) &#123;    interceptors.addAll(client.networkInterceptors());  &#125;  interceptors.add(new CallServerInterceptor(forWebSocket));  Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0,      originalRequest, this, client.connectTimeoutMillis(),      client.readTimeoutMillis(), client.writeTimeoutMillis());  boolean calledNoMoreExchanges = false;  try &#123;    Response response = chain.proceed(originalRequest);    if (transmitter.isCanceled()) &#123;      closeQuietly(response);      throw new IOException(&quot;Canceled&quot;);    &#125;    return response;  &#125; catch (IOException e) &#123;    calledNoMoreExchanges = true;    throw transmitter.noMoreExchanges(e);  &#125; finally &#123;    if (!calledNoMoreExchanges) &#123;      transmitter.noMoreExchanges(null);    &#125;  &#125;&#125;</code></pre><p>这里我们首先先说下这里运用的一个叫责任链的模式，就是你看到的interceptors.add()的东西，其实就是将一些拦截器一个一个的添加到一个list里面，然后通过 new RealInterceptorChain()进行每个拦截器的处理。这里的拦截器，包括okhttp默认的必须的一些拦截器，也包括用户在创建客户端的时候自定义的一些拦截器。这个咱们后面再来详细的解释。</p><p>接下来就是调用Response response = chain.proceed(originalRequest);方法来执行请求。</p><p>走完上述就走到了 client.dispatcher().finished(this);我们再来看finish后做了什么？</p><pre><code class="java">boolean isRunning = promoteAndExecute();</code></pre><p>这里就懵了呀，这不是又回到起点了吗？</p><p><strong>并不是！</strong></p><p>这里就是一个业务来手动循环，来继续遍历请求任务队列。通过手动推动dispatcher调度器对象，重新走上述的步骤。这就是okhttp的亮点所在哦。</p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>首先详细解释下什么叫做责任链模式：</p><blockquote><p>责任链模式：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链，当请求发生时，可将请求沿着这条链传递，直到有对象处理完成它为止。</p></blockquote><p>这里可能有点抽象，举个例子来解释下：就像我们用钉钉来进行请假一样，你提完审批之后-&gt;人事-&gt;小组组长-&gt;项目主管-&gt;部门领导。当人事觉得你理由不成立，直接给你拒了，那么剩下的三级就没必要再进行审核了，当人事这边觉得ok，小组组长这边才能看到你的申请，但是他觉得今天有任务节点，不能批，那么他才会拒绝。</p><h3 id="默认拦截器（okhttp自带的必须处理的无需用户定义添加）"><a href="#默认拦截器（okhttp自带的必须处理的无需用户定义添加）" class="headerlink" title="默认拦截器（okhttp自带的必须处理的无需用户定义添加）"></a>默认拦截器（okhttp自带的必须处理的无需用户定义添加）</h3><p><strong>RetryAndFollowUpInterceptor</strong>：处理错误，重定向等</p><p><strong>BridgeInterceptor：</strong> 添加必要请求头，gzip等</p><p><strong>CacheInterceptor：</strong> 缓存</p><p><strong>ConnectInterceptor：</strong> 打开一个链接</p><p><strong>CallServerInterceptor：</strong> 访问服务器</p><h3 id="常用自定义拦截器"><a href="#常用自定义拦截器" class="headerlink" title="常用自定义拦截器"></a>常用自定义拦截器</h3><p><strong>日志拦截器</strong></p><p><strong>Auth拦截器</strong></p><p>Token自动刷新拦截器</p><h2 id="Http-KeepAlive机制"><a href="#Http-KeepAlive机制" class="headerlink" title="Http KeepAlive机制"></a>Http KeepAlive机制</h2><p>Http协议中有一种KeepAlive机制，HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议），每次请求都会经过三次握手四次挥手过程，效率较低；当使用<code>Keep-Alive</code>模式时，客户端到服务器端的连接不会断开，当出现对服务器的后继请求时，客户端就会复用已建立的连接。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>节省了服务端CPU和内存适用量</li><li>降低拥塞控制 （TCP连接减少）</li><li>减少了后续请求的延迟（无需再进行握手）</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>对于某些低频访问的资源/服务，比如一个冷门的图片服务器，一年下不了几次，每下一次连接还保持就比较浪费了（这个场景举的不是很恰当）。Keep-Alive可能会非常影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间，额外占用了服务端的连接数。</p><blockquote><p>OkHttp 支持5个并发的KeepAlive，默认的存活时间时5分钟</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/freak_csh/article/details/95727115?spm=1001.2014.3001.5502">okhttp系列导航</a></p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> OkHttp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit源码解析</title>
      <link href="/posts/6cf2e7d7/"/>
      <url>/posts/6cf2e7d7/</url>
      
        <content type="html"><![CDATA[<h1 id="在上一篇文章详细讲解了Retrofit的基本使用，本篇文章从源码角度深度解析下Retrofit的具体实现过程。"><a href="#在上一篇文章详细讲解了Retrofit的基本使用，本篇文章从源码角度深度解析下Retrofit的具体实现过程。" class="headerlink" title="在上一篇文章详细讲解了Retrofit的基本使用，本篇文章从源码角度深度解析下Retrofit的具体实现过程。"></a>在<a href="https://blog.popperevan.work/posts/4bd912da/">上一篇</a>文章详细讲解了Retrofit的基本使用，本篇文章从源码角度深度解析下Retrofit的具体实现过程。</h1><span id="more"></span><p>在读过<a href="https://blog.popperevan.work/posts/4bd912da/">上一篇</a>文章之后，你是否有以下这些疑问：</p><ol><li>Retrofit具体对OkHttp做了哪些封装或者底层是如何用 OkHttp 请求的</li><li>请求接口具体对加载过程是怎样的</li><li>注解是怎么解析的</li><li>整个请求过程是怎样的</li><li>Converter的转换过程</li><li>如何与RxJava结合使用的</li></ol><p>下面我们在源码的角度来一一的看看Retrofit的具体实现过程。</p><h2 id="首先我们先看下实现请求用到的几个类的含义"><a href="#首先我们先看下实现请求用到的几个类的含义" class="headerlink" title="首先我们先看下实现请求用到的几个类的含义"></a>首先我们先看下实现请求用到的几个类的含义</h2><ol><li><p><strong>Retrofit实例</strong> 通过构建者模式来build一个全局的请求实例类，进行配置所需的基本的一些配置。</p></li><li><p><strong>Call实例</strong> 执行网络请求的是一个顶层接口，需要看源码中的具体实现类实际是一个 <strong>OkHttpCall</strong></p></li><li><p><strong>Callback</strong>  回调，对请求响应结果的回调</p></li></ol><h2 id="请求入口"><a href="#请求入口" class="headerlink" title="请求入口"></a>请求入口</h2><pre><code class="java">Call&lt;T&gt;.enqueue.enqueue</code></pre><blockquote><p>service.httpTest(“test”).enqueue函数，其中service.httpTest(“test”)就是上述的Call<T></p></blockquote><p>这是我们在RetrofitService接口中定义的，而在此之前我们需要初始化RetrofitService，然后返回的是 Call 对象。</p><p>我们先看下初始化的creat方法：</p><pre><code class="java">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;  validateServiceInterface(service);  return (T)      Proxy.newProxyInstance(          service.getClassLoader(),          new Class&lt;?&gt;[] &#123;service&#125;,          new InvocationHandler() &#123;            private final Platform platform = Platform.get();            private final Object[] emptyArgs = new Object[0];            @Override            public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)                throws Throwable &#123;              // If the method is a method from Object then defer to normal invocation.              if (method.getDeclaringClass() == Object.class) &#123;                return method.invoke(this, args);              &#125;              args = args != null ? args : emptyArgs;              return platform.isDefaultMethod(method)                  ? platform.invokeDefaultMethod(method, service, proxy, args)                  : loadServiceMethod(method).invoke(args);            &#125;          &#125;);&#125;</code></pre><p>这里首先是validateServiceInterface(service);方法，主要是就是验证我们定义的 RetrofitService是否是一个接口等，其实就是验证RetrofitService的合法性。 </p><p>然后就是通过一个动态代理，返回的RetrofitService实例。</p><blockquote><p>代理模式是Retrofit的一个重点内容，这里就不再赘述什么是动态代理，大家可自行百度。</p></blockquote><p>其中的method，args就是我们RetrofitService中对应的请求方法和参数。</p><p>返回值是一个三目运算，根据isDefaultMethod来决定具体返回什么，如果是默认方法（比如 Java8 ），就执行 platform 的默认方法。<strong>否则执行<code>loadServiceMethod</code>方法的<code>invoke</code>方法</strong>。</p><p><code>loadServiceMethod(method).invoke(args);</code>这个方法是我们这个 Retrofit 最关键的代码。下面我们来具体看看：</p><pre><code class="java">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);  if (result != null) return result;  synchronized (serviceMethodCache) &#123;    result = serviceMethodCache.get(method);    if (result == null) &#123;      result = ServiceMethod.parseAnnotations(this, method);      serviceMethodCache.put(method, result);    &#125;  &#125;  return result;&#125;</code></pre><ol><li>serviceMethodCache（ConcurrentHashMap） 中取一个 ServiceMethod</li><li>如果有返回</li><li>如果没有通过parseAnnotations 创建一个</li><li>parseAnnotations方法</li></ol><ul><li>解析<code>method(ApiService的method)</code>中的注解信息，解析注解并保存在<code>RequestFactory</code>工厂中，在请求时再通过<code>RequestFactory</code>将请求信息做拼装</li><li>调用<code>HttpServiceMethod</code>的<code>parseAnnotations</code>创建<code>ServiceMethod</code></li></ul><ol start="5"><li>放入缓存</li></ol><img src="https://cdn.jsdelivr.net/gh/evan0929/picture/img/%E6%88%AA%E5%B1%8F2021-12-15%20%E4%B8%8A%E5%8D%8812.36.54.png" alt="截屏2021-12-15 上午12.36.54" style="zoom:50%;" /><blockquote><p>这里之所以放入缓存，因为我们的请求方法可能会调用多次，缓存提升性能。</p></blockquote><ol start="6"><li>我们回过头去继续看parseAnnotations方法，最后返回的是：</li></ol><pre><code class="java">HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</code></pre><ol start="7"><li></li></ol><pre><code class="kotlin">#HttpServiceMethod.classstatic &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(            Retrofit retrofit, Method method, RequestFactory requestFactory) &#123;        boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;        boolean continuationWantsResponse = false;        boolean continuationBodyNullable = false;        Annotation[] annotations = method.getAnnotations();        Type adapterType;        //1.获取adapterType，默认为method返回值类型        if (isKotlinSuspendFunction) &#123;            Type[] parameterTypes = method.getGenericParameterTypes();            Type responseType =                    Utils.getParameterLowerBound(                            0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]);            if (getRawType(responseType) == Response.class &amp;&amp; responseType instanceof ParameterizedType) &#123;                // Unwrap the actual body type from Response&lt;T&gt;.                responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);                continuationWantsResponse = true;            &#125; else &#123;            &#125;            adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);            annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);        &#125; else &#123;            adapterType = method.getGenericReturnType();        &#125;        //2.创建CallAdapter        CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =                createCallAdapter(retrofit, method, adapterType, annotations);        Type responseType = callAdapter.responseType();        //3.创建responseConverter        Converter&lt;ResponseBody, ResponseT&gt; responseConverter =                createResponseConverter(retrofit, method, responseType);        okhttp3.Call.Factory callFactory = retrofit.callFactory;        //4.创建HttpServiceMethod类型具体实例        if (!isKotlinSuspendFunction) &#123;            return new HttpServiceMethod.CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);        &#125;        //兼容kotlin suspend方法        else if (continuationWantsResponse) &#123;            //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.            return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)                    new HttpServiceMethod.SuspendForResponse&lt;&gt;(                            requestFactory,                            callFactory,                            responseConverter,                            (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);        &#125; else &#123;            //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.            return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)                    new HttpServiceMethod.SuspendForBody&lt;&gt;(                            requestFactory,                            callFactory,                            responseConverter,                            (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,                            continuationBodyNullable);        &#125;    &#125;</code></pre><blockquote><p>注释1：获取<code>adapterType</code>，这里的<code>adapter</code>指的是<code>Retrofit</code>构建时通过<code>addCallAdapterFactory()</code>添加的类型，如果添加的是<code>RxJava</code>那<code>adapterType</code>便是<code>Observable</code>。默认是<code>method</code>返回值，同时也会做<code>kotlin suspend</code>适配</p><p>注释2：创建callAdapter，暂时掠过，下面详细描述</p><p>注释3：创建responseConverter，暂时掠过，下面详细描述</p><p>注释4：这里会创建具体的<code>HttpServiceMethod</code>类型实例，总共有三种类型<code>CallAdapted</code>、<code>SuspendForResponse</code>、<code>SuspendForBody</code>，第一种为默认类型，后两种可兼容kotlin suspend。内部主要做的事情其实很简单，就是通过内部的<code>adapter()</code>调用<code>callAdapter``adapter()</code>，具体代码就不贴了，感兴趣的自行查看</p></blockquote><ol start="8"><li><code>invoke()</code>方法： 创建了一个<code>OkHttpCall</code>实例，它内部其实就是对<code>OkHttp</code>的一系列操作。返回的<code>Call</code>对象没做任何操作，而是传入到<code>adapter()</code>方法一并返回来，字面意思应该是一个适配操作。</li></ol><blockquote><p>这里的代理模式有以下优势：1. 通过代理模式做一个<code>切面操作(AOP)</code>完美规避方法注解解析的操作浸入到业务的问题 2.事先不知道<code>RetrofitService</code>方法数量，就算知道也避免不了逐一解析而产生大量的模版代码，此时可通过引入<code>动态代理</code>在运行时动态解析</p></blockquote><p>我们看到这里其实解决了两个疑惑：1. 注解解析 2.请求接口的关联。那么我们继续往下看invoke()方法：</p><pre><code class="java">@Overridefinal @Nullable ReturnT invoke(Object[] args) &#123;  Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);  return adapt(call, args);&#125;</code></pre><ul><li>创建了一个Call对象，是 OkHttpCall，这里就知道接口声明的 Call 对象是怎么来的了</li><li>返回adapt，在不使用 Kotlin 协程的情况下，其实调用的是子类 CallAdapted 的 <code>adapt</code></li></ul><p>HttpServiceMethod的实现类的<code>adapter</code>会执行对应<code>CallAdapter</code>的<code>adapter</code> 我们就取默认的<code>CallAdapter</code> 即<code>DefaultCallAdapterFactory</code>通过<code>get</code>获取的<code>CallAdapter</code></p><pre><code class="java">#DefaultCallAdapterFactory.class   public @Nullable CallAdapter&lt;?, ?&gt; get(  return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;     @Override                public Type responseType() &#123;         return responseType;               &#125;     @Override      public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;       return executor == null ? call : new DefaultCallAdapterFactory.ExecutorCallbackCall&lt;&gt;(executor, call);                    &#125;      &#125;;   &#125;</code></pre><p>内部<code>adapt</code>即<code>ApiService method</code>最终返回的<code>ExecutorCallbackCall</code>是<code>OkHttpCall</code>装饰类，最后可通过<code>OkHttpCall</code>的<code>execute</code>发起请求，代码如下：</p><pre><code class="java">#OkHttpCall.classpublic Response&lt;T&gt; execute() throws IOException &#123;        okhttp3.Call call;        ...        return parseResponse(call.execute());    &#125;</code></pre><p><code>OkHttp</code>常规操作，再把关注点放到<code>onResponse</code>的<code>parseResponse</code></p><pre><code class="java">#OkHttpCall.class Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ...        T body = responseConverter.convert(catchingBody);...        return Response.success(body, rawResponse); &#125;</code></pre><p><code>responseConverter</code>会对<code>Body</code>做一个适配，如果<code>addConverterFactory</code>添加了<code>GsonConvert</code>那解析操作就会在此处进行.这个地方就解决我们疑惑对于Converter如何处理的遗憾，当然此处可以结合前面关于如何添加fastJson的实例使用，更香！</p><ol start="9"><li>还有最后一个问题就是如何和RxJava结合使用，这里就要解析下callAdapter这个了：</li></ol><ul><li>创建callAdapter</li></ul><pre><code class="java">#HttpServiceMethod.class private static &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt; createCallAdapter(     Retrofit retrofit, Method method, Type returnType, Annotation[] annotations) &#123;      return (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);  ... &#125;</code></pre><p>通过<code>retrofit#callAdapter()</code>获取<code>CallAdapter</code>，继续跟</p><ul><li><pre><code class="java">#Retrofit.classpublic CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;     return nextCallAdapter(null, returnType, annotations); &#125; public CallAdapter&lt;?, ?&gt; nextCallAdapter(                @Nullable     CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) &#123;       int start = callAdapterFactories.indexOf(skipPast) + 1;        for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;           //通过returnType在callAdapterFactories获取adapter工厂，再get adapter      CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this);                        if (adapter != null) &#123;       return adapter;          &#125;    &#125;      ...  &#125;</code></pre><p>先通过<code>returnType</code>在<code>callAdapterFactories</code>获取adapter工厂，再通过工厂<code>get()</code>获取<code>CallAdapter</code>实例。<code>callAdapterFactories</code>是<code>3.1</code>结尾<code>build()</code>中初始化的，通过<code>platform</code>添加默认类型，也可以通过<code>addCallAdapterFactory()</code>添加<code>RxJava</code>之类的适配器类型。</p><p>这里用到了两个设计模式<code>适配器</code>跟<code>策略</code></p><p><strong>适配器模式</strong></p><p>返回的<code>CallAdapter</code>其实就是<code>Call&lt;T&gt;</code>的适配器，假如你想让<code>Retrofit</code>配合<code>RxJava</code>使用，常规方式只能在业务中单独创建<code>Observable</code>并与<code>Call</code>融合，关于<code>Observable</code>与<code>Call</code>融合(适配)其实是与业务无关的，此时可以引入适配器模式将<code>Call</code>适配成<code>Observable</code>，将适配细节从业务层挪到<code>Retrofit</code>内部，符合<code>迪米特法则</code></p><p><strong>策略模式</strong></p><p>通过<code>ReturnT</code>获取对应的<code>CallAdapter</code>，如果<code>ReturnT</code>是<code>Call&lt;T&gt;</code>那获取的是<code>DefaultCallAdapterFactory</code>创建的实例，如果是<code>Observable&lt;T&gt;</code>则获取的是<code>RxJava2CallAdapterFactory</code>创建的实例。假如想新增一种适配器只需明确<code>ReturnT</code>，创建对应工厂再通过<code>addCallAdapterFactory</code>添加即可，<code>Retrofit</code>会通过<code>ReturnT</code>自动寻找对应<code>CallAdapter</code>，符合<code>开闭原则(扩展开放)</code></p></li></ul><p>最后总结下Retrofit的整体请求流程：</p><img src="https://cdn.jsdelivr.net/gh/evan0929/picture/img/%E6%88%AA%E5%B1%8F2021-12-15%20%E4%B8%8A%E5%8D%881.31.24.png" alt="截屏2021-12-15 上午1.31.24" style="zoom:50%;" /><p>Retrofit源码相关的内容就先解析到这吧</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> Retrofit </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp基本应用</title>
      <link href="/posts/88a80a38/"/>
      <url>/posts/88a80a38/</url>
      
        <content type="html"><![CDATA[<h1 id="OkHttp基本使用"><a href="#OkHttp基本使用" class="headerlink" title="OkHttp基本使用"></a>OkHttp基本使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    OkHttp 是一款高效的HTTP客户端，支持连接同一地址的链接共享同一个socket，通过连接池减小响应延迟，GZIP压缩，请求缓存等优势，核心主要有路由，连接协议，拦截器，代理，安全性认证，连接池以及网络适配。</p><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://square.github.io/okhttp/">官网地址</a></p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><p>先上代码：</p><ol><li><p>get同步请求</p><pre><code class="java">   public static void getByExecute()&#123;        //创建客户端        OkHttpClient client=new OkHttpClient();        //url        String url = &quot;https://www.baidu.com/&quot;;        //创建请求封装类（默认是get请求故可以不加）        Request request = new Builder()                .url(url)                .build();        //创建发送请求类        Call call=client.newCall(request);        // 同步请求要在子线程中开启        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    //创建请求响应封装类                    Response response = call.execute();                    Log.e(TAG, &quot;okHttpGet run: response:&quot;+ response.body().string());                &#125; catch (IOException e) &#123;                    e.printStackTrace();                    Log.e(TAG,e.getMessage());                &#125;            &#125;        &#125;).start();    &#125;</code></pre></li><li><p>get异步请求</p></li></ol><pre><code class="java"> public static void getByEnqueue()&#123;        //第二种创建client的方法        OkHttpClient okHttpClient = new OkHttpClient.Builder().build();        String url = &quot;https://www.baidu.com/&quot;;        Request request = new Builder().url(url).build();        Call call=okHttpClient.newCall(request);        call.enqueue(new Callback() &#123;            @Override            public void onFailure(Call call, IOException e) &#123;                Log.e(TAG, &quot;okHttpGet run: response:&quot;+ &quot;onFailure&quot; +e.getMessage());            &#125;            @Override            public void onResponse(Call call, Response response) throws IOException &#123;                Log.e(TAG, &quot;okHttpGet run: response:&quot;+ response.code());                Log.e(TAG, &quot;okHttpGet run: response:&quot;+ response.body().string());            &#125;        &#125;);    &#125;</code></pre><p>从上述代码咱们来入手分析下：</p><ol><li><p>okhttp的get请求分为同步和异步两种请求方式</p></li><li><p>创建客户端（直接new的方法和调用builder的方法进行创建，其实在new方法的内部也是调用builder的方式，但是不能添加拦截器、超时参数、log日志、头文件、缓存等属性）</p></li><li><p>创建请求封装类（okhttp默认是get请求故可不加get()）</p></li><li><p>创建发送请求类</p></li><li><p>根据需求调用同步/异步请求方法</p></li></ol><blockquote><p>需要注意的是同步的方法会阻塞线程，需要开启子线程进行调用</p><p>异步调用的回调函数是在子线程，不能进行更新UI等操作，需要<code>runOnUiThread()</code>方法或者<code>Handler</code>来处理</p></blockquote><h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><p>​    <strong>post</strong>请求需要在<strong>Request</strong>传递一个<strong>RequestBody</strong>作为post的参数，<strong>RequestBody</strong>有两个子类：<strong>FormBody</strong>和<strong>MultipartBody</strong></p><ol><li>json数据提交</li></ol><pre><code class="java">public static void postByJson(String json)&#123;    //创建客户端    OkHttpClient okHttpClient = new OkHttpClient.Builder().build();      //创建json      public static final MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;);    //创建RequestBody    RequestBody body = RequestBody.create(JSON, json);    //创建请求封装类    Request request = new Request.Builder()            .url(&quot;http://www.jianshu.com/&quot;)            .post(body)            .build();    //创建发送请求类    Call call = okHttpClient.newCall(request);    //发送请求    call.enqueue(new Callback() &#123;        @Override        public void onFailure(Call call, IOException e) &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ &quot;onFailure&quot; +e.getMessage());        &#125;        @Override        public void onResponse(Call call, Response response) throws IOException &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ response.code());        &#125;    &#125;);&#125;</code></pre><ol start="2"><li>表单提交</li></ol><p>FromBody用于提交表单键值对</p><pre><code class="java">public static void postByFormBody()&#123;    //创建客户端    OkHttpClient okHttpClient = new OkHttpClient.Builder().build();    //创建form表单    FormBody formBody = new FormBody.Builder()            .add(&quot;username&quot;, &quot;admin&quot;)            .add(&quot;password&quot;, &quot;admin&quot;)            .build();    //创建请求封装类    Request request = new Request.Builder()            .url(&quot;http://www.jianshu.com/&quot;)            .post(formBody)            .build();    //创建发送请求类    Call call = okHttpClient.newCall(request);    //发送请求    call.enqueue(new Callback() &#123;        @Override        public void onFailure(Call call, IOException e) &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ &quot;onFailure&quot; +e.getMessage());        &#125;        @Override        public void onResponse(Call call, Response response) throws IOException &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ response.code());        &#125;    &#125;);&#125;</code></pre><p>当然这是最简单的表单提交直接在Formbody对象创建的过程中add API所需的params。我们在实际工作中肯定不会这样来做，不仅代码冗余而且扩展性太差，我们不能每个借口都初始化一边Formbody对象，然后一个个的add。我们肯定是传递params的方式来做。这里给大家演示下：</p><pre><code class="java">public static void postByFormBody(String userName,String password )&#123;    //创建客户端    OkHttpClient okHttpClient = new OkHttpClient.Builder().build();    //创建hashmap    HashMap&lt;String,String&gt; paramsMap=new HashMap&lt;&gt;();    paramsMap.put(&quot;username&quot;,userName);    paramsMap.put(&quot;password&quot;,password);    //创建form表单    FormBody.Builder builder = new FormBody.Builder();    for (String key : paramsMap.keySet()) &#123;        //追加表单信息        builder.add(key, paramsMap.get(key));    &#125;    RequestBody formBody=builder.build();    //创建请求封装类    Request request = new Request.Builder()            .url(&quot;http://www.jianshu.com/&quot;)            .post(formBody)            .build();    //创建发送请求类    Call call = okHttpClient.newCall(request);    //发送请求    call.enqueue(new Callback() &#123;        @Override        public void onFailure(Call call, IOException e) &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ &quot;onFailure&quot; +e.getMessage());        &#125;        @Override        public void onResponse(Call call, Response response) throws IOException &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ response.code());        &#125;    &#125;);&#125;</code></pre><p>看完之后，你要说了这样写也没少写多少代码，也没看到代码的优雅之处呀。别急！，这里就要给大家说了我们这里之所以使用<strong>HashMap</strong>这样的数据结构，优点在于他的查找速度为O(1),很快。但是哈，对于我们工作中的API来说，其实没有那么多的params的，这里的优势也体现不出来。并且<strong>HashMap</strong>消耗内存比较大。所以这里在params少的情况下不太提倡，而且我们经常传参数都是用的JAVA bean的形式。所以这里给出我们常用的调用方式：</p><ol><li>首先我们新建一个bean</li></ol><pre><code class="java">public class RequestBean implements Serializable&#123;    private String name;    private String value;    public RequestBean(String name, String value) &#123;        this.name = name;        this.value = value;    &#125;    public String name() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getValue() &#123;        return value;    &#125;    public void setValue(String value) &#123;        this.value = value;    &#125;&#125;</code></pre><ol start="2"><li>调用</li></ol><pre><code class="java">public static void postByFormBody()&#123;    //创建客户端    OkHttpClient okHttpClient = new OkHttpClient.Builder().build();    //创建一个FormBody.Builder    FormBody.Builder builder=new FormBody.Builder();      //创建list    List&lt;RequestBean&gt;beans=new ArrayList&lt;&gt;();      beans.add(new RequestBean(&quot;userName&quot;,&quot;admin&quot;));    beans.add(new RequestBean(&quot;password&quot;,&quot;123456&quot;));       if (beans!=null&amp;&amp;beans.size()&gt;0)&#123;            for (final RequestBean p : beans) &#123;                builder.add(p.getName(),p.getValue());            &#125;        &#125;      //创建RequestBody    RequestBody formBody=builder.build();    //创建请求封装类    Request request = new Request.Builder()            .url(&quot;http://www.jianshu.com/&quot;)            .post(formBody)            .build();    //创建发送请求类    Call call = okHttpClient.newCall(request);    //发送请求    call.enqueue(new Callback() &#123;        @Override        public void onFailure(Call call, IOException e) &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ &quot;onFailure&quot; +e.getMessage());        &#125;        @Override        public void onResponse(Call call, Response response) throws IOException &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ response.code());        &#125;    &#125;);&#125;</code></pre><ol start="3"><li>文件上传</li></ol><p>MultipartBody可以构建与HTML文件上传格式兼容的复杂请求体。</p><p>此处以上传图片为例：</p><pre><code class="java">public static void postByFile()&#123;    //创建客户端    OkHttpClient okHttpClient = new OkHttpClient.Builder().build();    //创建一个file对象    File file = new File(&quot;File path&quot;);    //创建RequestBody     RequestBody requestBody = RequestBody.create(MediaType.parse(&quot;application/octet-stream&quot;), file);    //创建MultipartBody    MultipartBody multipartBody = new MultipartBody.Builder()            .setType(MultipartBody.FORM)            .addFormDataPart(&quot;param1&quot;, &quot;value1&quot;)            .addFormDataPart(&quot;param2&quot;, &quot;value2&quot;)            .addFormDataPart(&quot;param3&quot;, &quot;value3&quot;)            .addFormDataPart(&quot;pic&quot;, &quot;1.png&quot;, requestBody)            .build();    //创建请求封装类    Request request = new Request.Builder()            .url(&quot;http://www.jianshu.com/&quot;)            .post(multipartBody)            .build();    //创建发送请求类    Call call = okHttpClient.newCall(request);    //发送请求    call.enqueue(new Callback() &#123;        @Override        public void onFailure(Call call, IOException e) &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ &quot;onFailure&quot; +e.getMessage());        &#125;        @Override        public void onResponse(Call call, Response response) throws IOException &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ response.code());        &#125;    &#125;);&#125;</code></pre><blockquote><p>文件依然是通过addFormDataPart进行添加，只不过多了一个RequestBody参数<br>将文件存放到RequestBody中，然后将该RequestBody添加到MultipartBody中，组成一个完整的RequestBody用于请求<br>“application/octet-stream”是以文件流方式传输，适合于所有文件，也可以使用指定的Content-Type进行传输，比如<code>&quot;application/x-png&quot;</code></p></blockquote><p>通过MultipartBody就可以轻松将文件上传至服务器，无需进行复杂的流操作，但是美中不足的是没有进度信息，如果文件较大的情况下，上传耗时比较久，只有文件完全上传后才有回调，十分不友好.</p><ol start="4"><li>文件上传进度</li></ol><p>OkHttp并没有提供进度的相关回调或者接口，但是POST都是通过RequestBody进行请求的，查看RequestBody类就可以发现RequestBody只有三个主要方法</p><pre><code class="java">/** Returns the Content-Type header for this body. */public abstract @Nullable MediaType contentType();/*** Returns the number of bytes that will be written to &#123;@code sink&#125; in a call to &#123;@link #writeTo&#125;, * or -1 if that count is unknown. */public long contentLength() throws IOException &#123;  return -1;&#125;/** Writes the content of this request to &#123;@code sink&#125;. */public abstract void writeTo(BufferedSink sink) throws IOException;</code></pre><p>根据注释可以明确各个方法的作用</p><ol><li>contentType() 返回Content-Type</li><li>contentLength() 返回已写入数据大小</li><li>writeTo 将数据写入BufferedSink</li></ol><p>RequestBody还提供了几个请求的实现，当上传文件的时候的实现方法：</p><pre><code class="java">/** Returns a new request body that transmits the content of &#123;@code file&#125;. */public static RequestBody create(final @Nullable MediaType contentType, final File file) &#123;  if (file == null) throw new NullPointerException(&quot;file == null&quot;);  return new RequestBody() &#123;    @Override public @Nullable MediaType contentType() &#123;      return contentType;    &#125;    @Override public long contentLength() &#123;      return file.length();    &#125;    @Override public void writeTo(BufferedSink sink) throws IOException &#123;      Source source = null;      try &#123;        source = Okio.source(file);        sink.writeAll(source);      &#125; finally &#123;        Util.closeQuietly(source);      &#125;    &#125;  &#125;;&#125;</code></pre><p>因此只要获取BufferedSink的大小就可以获取文件传输的大小，但是OkHttp提供的方法中是将文件通过writeAll()进行写入的，无法确定每个时间段具体传输了多少，继续查看writeAll()</p><pre><code class="java">@Override public long writeAll(Source source) throws IOException &#123;    if (source == null) throw new IllegalArgumentException(&quot;source == null&quot;);    long totalBytesRead = 0;    for (long readCount; (readCount = source.read(this, Segment.SIZE)) != -1; ) &#123;      totalBytesRead += readCount;    &#125;    return totalBytesRead;  &#125;</code></pre><p>到这就很明了了，writeAll每次写入的是Segment.SIZE(8192)字节，我们只要将writeAll提取出来就可以自己控制上传的进度了</p><pre><code class="java">public class FileRequestBody extends RequestBody &#123;    private RequestBody mRequestBody;    private long mContentLength;    private LoadingListener mLoadingListener;    public FileRequestBody(RequestBody requestBody, LoadingListener loadingListener) &#123;        mRequestBody = requestBody;        mLoadingListener = loadingListener;    &#125;    //文件的总长度    @Override    public long contentLength() &#123;        try &#123;            if (mContentLength == 0)                mContentLength = mRequestBody.contentLength();            return mContentLength;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return -1;    &#125;    @Override    public MediaType contentType() &#123;        return mRequestBody.contentType();    &#125;    @Override    public void writeTo(BufferedSink sink) throws IOException &#123;        ByteSink byteSink = new ByteSink(sink);        BufferedSink mBufferedSink = Okio.buffer(byteSink);        mRequestBody.writeTo(mBufferedSink);        mBufferedSink.flush();    &#125;    private final class ByteSink extends ForwardingSink &#123;        //已经上传的长度        private long mByteLength = 0L;        ByteSink(Sink delegate) &#123;            super(delegate);        &#125;        @Override        public void write(Buffer source, long byteCount) throws IOException &#123;            super.write(source, byteCount);            mByteLength += byteCount;            mLoadingListener.onProgress(mByteLength, contentLength());        &#125;    &#125;    public interface LoadingListener &#123;        void onProgress(long currentLength, long contentLength);    &#125;&#125;</code></pre><p>调用的时候也只需要将</p><pre><code class="java">RequestBody requestBody = RequestBody.create(MediaType.parse(&quot;application/octet-stream&quot;), file);</code></pre><p>替换成</p><pre><code class="java">RequestBody requestBody = new FileRequestBody(MediaType.parse(&quot;application/octet-stream&quot;), file);</code></pre><ol start="5"><li><p>图片下载，文件下载</p><p>图片下载是通过回调的Response拿到byte[]然后decode成图片；<br>文件下载，就是拿到inputStream做写文件操作；</p></li><li><p>请求回调</p></li></ol><p>同步请求：</p><pre><code class="java">Response response = call.execute();</code></pre><p>异步请求是在onResponse回调中</p><p>同样都会拿到一个<strong>Response</strong>对象：</p><pre><code class="java">//请求响应数据ResponseBody对象response.body();//请求响应的code 如成功200 response.code();//请求响应的header信息response.headers();</code></pre><p>数据处理：</p><pre><code class="java">//请求响应数据处理response.body().string();response.body().bytes();response.body().charStream();response.body().byteStream();</code></pre><p>okhttp会返回以上几种常用格式的响应数据，可根据业务的具体需求对数据进行格式化。</p><h3 id="最后来个流程图"><a href="#最后来个流程图" class="headerlink" title="最后来个流程图"></a>最后来个流程图</h3><p><img src="https://cdn.jsdelivr.net/gh/evan0929/picture/img/%E6%88%AA%E5%B1%8F2021-12-02%20%E4%B8%8B%E5%8D%8811.34.19-20211203011800461.png" alt="截屏2021-12-02 下午11.34.19"></p><center> -----本文结束啦感谢您的阅读-----]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> OkHttp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Retrofit基本使用</title>
      <link href="/posts/4bd912da/"/>
      <url>/posts/4bd912da/</url>
      
        <content type="html"><![CDATA[<h1 id="在之前的文章介绍了OkHttp的基本使用和源码解析，本文开始介绍Retrofit的使用"><a href="#在之前的文章介绍了OkHttp的基本使用和源码解析，本文开始介绍Retrofit的使用" class="headerlink" title="在之前的文章介绍了OkHttp的基本使用和源码解析，本文开始介绍Retrofit的使用"></a>在之前的文章介绍了OkHttp的<a href="https://blog.popperevan.work/posts/88a80a38/">基本使用</a>和<a href="https://blog.popperevan.work/posts/ff8004af/">源码解析</a>，本文开始介绍Retrofit的使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>官方的介绍：A Type-safe HTTP client for Android and Java</p><p>其实就是Square公司基于OkHttp封装的针对Android和Java使用的一个类型安全的http网络请求库 。</p><blockquote><p><a href="https://square.github.io/retrofit/">官网地址</a></p><p><a href="https://github.com/square/retrofit">github地址</a></p></blockquote><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>支持RESTful API设计风格</li><li>通过注解配置请求：请求方法，请求头，请求参数，返回值等</li><li>搭配多种Converter来解析数据和序列化：Gson，Jackson，Protobuff，fastjson等</li><li>支持RxJava</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>添加依赖</li></ol><pre><code class="java">implementation &#39;com.squareup.retrofit2:retrofit:2.9.0&#39;implementation &#39;com.squareup.retrofit2:converter-gson:2.9.0&#39; //json转换implementation &#39;com.squareup.retrofit2:converter-scalars:2.9.0&#39;//String 类型转换</code></pre><ol start="2"><li>权限</li></ol><pre><code class="java">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; //网络&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; //写&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; //读</code></pre><ol start="3"><li>网络请求接口</li></ol><pre><code class="java">public interface RetrofitService &#123;    @GET(&quot;userInfo&quot;)    Call&lt;BaseBean&lt;UserInfoBean&gt;&gt; getTest();    @GET()    Call&lt;BaseBean&lt;UserInfoBean&gt;&gt; getTest(@Url() String url);&#125;</code></pre><blockquote><p>Retrofit 将网络http请求抽象为Java接口的形式，通过注解的方式配置和描述请求参数。</p></blockquote><p>4.创建Retrofit实例</p><pre><code class="java"> Retrofit retrofit=new Retrofit.Builder()            .baseUrl(baseUrl)            .addConverterFactory(GsonConverterFactory.create())            .build();</code></pre><ol start="5"><li>绑定请求接口</li></ol><pre><code class="java">RetrofitService service=retrofit.create(RetrofitService.class);</code></pre><ol start="6"><li>请求</li></ol><pre><code class="java">service.httpTest(&quot;test&quot;).enqueue(new Callback&lt;BaseBean&lt;UserInfoBean&gt;&gt;() &#123;            @Override            public void onResponse(Call&lt;BaseBean&lt;UserInfoBean&gt;&gt; call, Response&lt;BaseBean&lt;UserInfoBean&gt;&gt;                                                                                                 response) &#123;                Log.e(TAG, response.body().toString());            &#125;            @Override            public void onFailure(Call&lt;BaseBean&lt;UserInfoBean&gt;&gt; call, Throwable t) &#123;                Log.e(TAG, t.getMessage());            &#125;        &#125;);</code></pre><p>7.请求结果在回调中获取和处理</p><p><strong>以上是Retrofit的基本使用流程，下面给一个清晰的流程图</strong></p><img src="https://cdn.jsdelivr.net/gh/evan0929/picture/img/%E6%88%AA%E5%B1%8F2021-12-14%20%E4%B8%8B%E5%8D%8810.30.26.png" alt="截屏2021-12-14 下午10.30.26" style="zoom:50%;" /><h2 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h2><p>注解分为三类：请求方法类注解、标记类注解、请求参数类注解</p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>POST：用于在服务器新建资源，对应的资源操作是INSERT，非幂等且不安全</p><p>DELETE：用于从服务器删除资源，对应的资源操作是DELETE，幂等且不安全</p><p>PUT：用于从服务器更新资源，对应的资源操作是UPDATE，幂等且不安全</p><p>GET：用于从服务器获取资源，对应的资源操作是SELECT，幂等且安全</p><p><strong>详细说明</strong></p><p>@GET </p><blockquote><p>用于发送一个GET请求，GET注解一般必须添加相对路径或绝对路径或者全路径,如果不想在GET注解后添加请求路径,则可以在方法的第一个参数中用@Url注解添加请求路径。</p></blockquote><p>两种调用方法：</p><pre><code class="java">@GET(&quot;userInfo&quot;)Call&lt;BaseBean&lt;UserInfoBean&gt;&gt; getTest();@GET()Call&lt;BaseBean&lt;UserInfoBean&gt;&gt; getTest(@Url() String url);//这里传参的url为&quot;userInfo&quot;</code></pre><p>@POST</p><blockquote><p>用于发送一个POST请求，POST注解一般必须添加相对路径或绝对路径或者全路径,如果不想在POST注解后添加请求路径,则可以在方法的第一个参数中用@Url注解添加请求路径。</p></blockquote><p>两种调用方法：</p><pre><code class="java">@POST(&quot;user_info&quot;)Call&lt;BaseBean&lt;UserInfoBean&gt;&gt; postTest();@POST()Call&lt;BaseBean&lt;UserInfoBean&gt;&gt; postTest(@Url() String url);//这里传参的url为&quot;user_info&quot;</code></pre><p> @PUT</p><blockquote><p>用于发送一个PUT请求，PUT注解一般必须添加相对路径或绝对路径或者全路径,如果不想在PUT注解后添加请求路径,则可以在方法的第一个参数中用@Url注解添加请求路径。</p></blockquote><p> @DELETE</p><blockquote><p>用于发送一个DELETE请求，DELETE注解一般必须添加相对路径或绝对路径或者全路径,如果不想在DELETE注解后添加请求路径,则可以在方法的第一个参数中用@Url注解添加请求路径。</p></blockquote><p> @PATH </p><blockquote><p>作用于方法的参数，在URL路径段中替换指定的参数值。使用String.valueOf()和URL编码将值转换为字符串，使用该注解定义的参数的值不可为空，参数值默认使用URL编码。</p></blockquote><pre><code class="java">@GET(&quot;userInfo/&#123;type&#125;&quot;)Call&lt;BaseBean&lt;UserInfoBean&gt;&gt; pathTest(@Path(&quot;type&quot;) String type);</code></pre><p>@HEAD </p><blockquote><p>用于发送一个HEAD请求，HEAD注解一般必须添加相对路径或绝对路径或者全路径,如果不想在HEAD注解后添加请求路径,则可以在方法的第一个参数中用@Url注解添加请求路径。</p></blockquote><p>@OPTIONS</p><blockquote><p>用于发送一个OPTIONS请求，OPTIONS注解一般必须添加相对路径或绝对路径或者全路径,如果不想在OPTIONS注解后添加请求路径,则可以在方法的第一个参数中用@Url注解添加请求路径。</p></blockquote><p> @HTTP</p><blockquote><p>@HTTP替换@GET、@POST、@PUT、@DELETE、@HEAD注解的作用以及更多功能拓展，具体使用：通过method、path、hasBody进行设置。</p></blockquote><pre><code class="java">@HTTP(method = &quot;GET&quot;,path = &quot;userInfo/&#123;type&#125;&quot;)//其中hasBody默认是falseCall&lt;BaseBean&lt;UserInfoBean&gt;&gt; httpTest(@Path(&quot;type&quot;) String type);</code></pre><h3 id="标记类"><a href="#标记类" class="headerlink" title="标记类"></a>标记类</h3><p>@FormUrlEncoded </p><blockquote><p>表示请求体是一个Form表单，发送form-encoded的数据，每个键值对需要用@Filed来注解键名，随后的对象需要提供值。<br>用于修饰Field注解和FieldMap注解，使用该注解时，表示请求正文将使用表单网址编码，字段应该声明为参数，并用@Field注释或@FieldMap注释。</p></blockquote><pre><code class="java">@POST(&quot;user_info&quot;)@FormUrlEncodedCall&lt;BaseBean&lt;UserInfoBean&gt;&gt; postTest2(@Field(&quot;userName&quot;) String userName);</code></pre><p>@Multipart </p><blockquote><p>使用该注解,表示请求体是多部分的。 每一部分作为一个参数,且用Part注解声明，随后的对象需要提供值</p></blockquote><p>@Streaming</p><blockquote><p>处理返回Response的方法的响应体，即没有将body（）转换为byte []。</p></blockquote><h3 id="网络请求参数"><a href="#网络请求参数" class="headerlink" title="网络请求参数"></a>网络请求参数</h3><p>@Header @headers</p><blockquote><p>添加请求头 &amp; 添加不固定请求头</p></blockquote><p> @URL </p><blockquote><p>直接传入一个请求的 URL变量 用于URL设置</p></blockquote><blockquote><pre><code>    @GET    Call&lt;ResponseBody&gt; testUrlAndQuery(@Url String url, @Query(&quot;showAll&quot;) boolean showAll);   // 当有URL注解时，@GET传入的URL就可以省略   // 当GET、POST...HTTP等方法中没有设置Url时，则必须使用 &#123;@link Url&#125;提供</code></pre></blockquote><p>@Body</p><blockquote><p>以 Post方式 传递 自定义数据类型 给服务器,如果提交的是一个Map，那么作用相当于 @Field,不过Map要经过 FormBody.Builder 类处理成为符合 Okhttp 格式的表单</p></blockquote><p> @Path</p><blockquote><p>URL地址的缺省值</p></blockquote><p> @Field @FieldMap </p><blockquote><p>发送 Post请求 时提交请求的表单字段,与 @FormUrlEncoded 注解配合使用</p></blockquote><p>@Part @PartMap</p><blockquote><p>发送 Post请求 时提交请求的表单字段,与@Field的区别：功能相同，但携带的参数类型更加丰富，包括数据流，所以适用于 有文件上传 的场景,与 @Multipart 注解配合使用</p></blockquote><p> @Query @QueryMap</p><blockquote><p>用于 @GET 方法的查询参数（Query = Url 中 ‘?’ 后面的 key-value）<br>如：url = <a href="http://www.println.net/?cate=android%EF%BC%8C%E5%85%B6%E4%B8%AD%EF%BC%8CQuery">http://www.println.net/?cate=android，其中，Query</a> = cate<br>配置时只需要在接口方法中增加一个参数即可</p></blockquote><p>以上注解根据后端接口返回格式灵活运用</p><h3 id="数据解析器（Converter）"><a href="#数据解析器（Converter）" class="headerlink" title="数据解析器（Converter）"></a>数据解析器（Converter）</h3><p>Retrofit支持多种数据解析器，需要在Gradle中添加相关的依赖</p><table><thead><tr><th align="left"><strong>数据解析器</strong></th><th align="center"><strong>Gradle依赖</strong></th></tr></thead><tbody><tr><td align="left">Gson</td><td align="center">com.squareup.retrofit2:converter-gson:2.9.0</td></tr><tr><td align="left">Jackson</td><td align="center">com.squareup.retrofit2:converter-jackson:2.9.0</td></tr><tr><td align="left">Simple XML</td><td align="center">com.squareup.retrofit2:converter-simplexml:2.9.0</td></tr><tr><td align="left">Protobuf</td><td align="center">com.squareup.retrofit2:converter-protobuf:2.9.0</td></tr><tr><td align="left">Moshi</td><td align="center">com.squareup.retrofit2:converter-moshi:2.9.0</td></tr><tr><td align="left">Wire</td><td align="center">com.squareup.retrofit2:converter-wire:2.9.0</td></tr><tr><td align="left">Scalars</td><td align="center">com.squareup.retrofit2:converter-scalars:2.9.0</td></tr></tbody></table><p>以上是官方支持的7种Converter，这里还有一种我们开发过程中常用的fastJson，这个需要我们做以下步骤来扩展Converter，以支持fastJson：</p><ol><li><pre><code>implementation &#39;com.alibaba:fastjson:1.1.72.android&#39;</code></pre></li><li><p>创建FastJsonRequestBodyConverter类</p></li></ol><pre><code class="java">public class FastJsonRequestBodyConverter &lt;T&gt; implements Converter&lt;T, RequestBody&gt; &#123;    private static final MediaType MEDIA_TYPE = MediaType.parse(&quot;application/json; charset=UTF-8&quot;);    @Nullable    @Override    public RequestBody convert(T value) throws IOException &#123;        return RequestBody.create(MEDIA_TYPE, JSON.toJSONBytes(value));    &#125;&#125;</code></pre><ol start="3"><li>创建FastJsonResponseBodyConverter类</li></ol><pre><code class="java">public class FastJsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody,T&gt; &#123;    private final Type type;    public FastJsonResponseBodyConverter(Type type) &#123;        this.type = type;    &#125;    @Nullable    @Override    public T convert(ResponseBody value) throws IOException &#123;         BufferedSource bufferedSource=Okio.buffer(value.source());        String buffer=bufferedSource.readUtf8();        bufferedSource.close();        return JSON.parseObject(buffer,type);    &#125;&#125;</code></pre><ol start="4"><li>首先创建FastJsonConverterFactory 类，并继承Converter.Factory，重写其中的responseBodyConverter方法与requestBodyConverter方法。</li></ol><pre><code class="java">public class FastJsonConverterFactory extends Converter.Factory&#123;    public static FastJsonConverterFactory create()&#123;        return new FastJsonConverterFactory();    &#125;    @Nullable    @Override    public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;        return new FastJsonResponseBodyConverter&lt;&gt;(type);    &#125;    @Nullable    @Override    public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;        return new FastJsonRequestBodyConverter&lt;&gt;();    &#125;&#125;</code></pre><ol start="5"><li>调用</li></ol><pre><code class="java">Retrofit retrofit=new Retrofit.Builder()        .baseUrl(baseUrl)        .addConverterFactory(FastJsonConverterFactory.create())        .build();</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/a3e162261ab6">Android Retrofit 2.0 的详细 使用攻略（含实例讲解)</a></p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> Retrofit </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava从入门到放弃（一）</title>
      <link href="/posts/d717c770/"/>
      <url>/posts/d717c770/</url>
      
        <content type="html"><![CDATA[<h1 id="本系列文章介绍RxJava库在Android上的使用和源码分析。"><a href="#本系列文章介绍RxJava库在Android上的使用和源码分析。" class="headerlink" title="本系列文章介绍RxJava库在Android上的使用和源码分析。"></a>本系列文章介绍RxJava库在Android上的使用和源码分析。</h1><h1 id="本文只要介绍RxJava库在Android上的基本使用。"><a href="#本文只要介绍RxJava库在Android上的基本使用。" class="headerlink" title="本文只要介绍RxJava库在Android上的基本使用。"></a>本文只要介绍RxJava库在Android上的基本使用。</h1><span id="more"></span><h1 id="什么是RxJava"><a href="#什么是RxJava" class="headerlink" title="什么是RxJava"></a>什么是RxJava</h1><p>​    RxJava的官方介绍：</p><pre><code>a library for composing asynchronous and event-based programs using observable sequences for the Java VM</code></pre><p>​    中文意思就是:一个<strong>库，</strong>一个什么样子的库呢。在<code>Java VM</code>上使用可观测的序列来组成<strong>异步的</strong>、<strong>基于事件</strong>的程序的库。那么为什么叫<code>Rx</code>？<code>Rx</code>全称为<code>ReactiveX(Reactive Extensions)</code>。什么又叫做<code>Rx</code>,<br>这是一个使用<strong>可观察数据流</strong>进行<strong>异步编程</strong>的<strong>编程接口</strong>，是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的进行异步和基于事件的程序。</p><p>​    <a href="https://github.com/ReactiveX/RxJava">RxJava项目地址</a></p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><center>-----本文结束啦感谢您的阅读-----]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown扩展语法</title>
      <link href="/posts/c677b245/"/>
      <url>/posts/c677b245/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown扩展语法"><a href="#Markdown扩展语法" class="headerlink" title="Markdown扩展语法"></a>Markdown扩展语法</h1><p>在<a href="https://blog.popperevan.work/posts/5d36ff15/">上一篇文章</a>,记录了Markdown的基本语法，本文记录下我们常用的扩展语法。</p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>当需要表示废弃的文字时或过时的方法，就需要删除线。加删除线的文本，在编译为 Html 后会被<code>&lt;s&gt;</code>和<code>&lt;/s&gt;</code>标签包围。<br>删除线的表现方法是：文字前后用<code>~~</code>包围。切记是半角<code>~</code>而非全角<code>～</code>，注意全角和半角的区别。</p><pre><code>~~要删除的方法~~</code></pre><p>效果：<del>要删除的文字</del></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>我是锚点</p><h3 id="单元格和表头"><a href="#单元格和表头" class="headerlink" title="单元格和表头"></a>单元格和表头</h3><p>使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：</p><pre><code>姓名  | 代表作---- | ---苏轼  | 水调歌头纳兰性德 | 饮水词李太白 | 梦游天姥吟留别</code></pre><table><thead><tr><th>姓名</th><th>代表作</th></tr></thead><tbody><tr><td>苏轼</td><td>水调歌头</td></tr><tr><td>纳兰性德</td><td>饮水词</td></tr><tr><td>李太白</td><td>梦游天姥吟留别</td></tr></tbody></table><p>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界：</p><pre><code>| 姓名     |        代表作 || ----    | ------------ || 苏轼     |      水调歌头 || 纳兰性德 |        饮水词 || 李太白   | 梦游天姥吟留别 |</code></pre><table><thead><tr><th>姓名</th><th>代表作</th></tr></thead><tbody><tr><td>苏轼</td><td>水调歌头</td></tr><tr><td>纳兰性德</td><td>饮水词</td></tr><tr><td>李太白</td><td>梦游天姥吟留别</td></tr></tbody></table><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式：</p><ul><li><code>:---</code> 代表左对齐</li><li><code>:--:</code> 代表居中对齐</li><li><code>---:</code> 代表右对齐</li></ul><pre><code>| left    |      center | right   || :---    |      :--:   | ---:    || 苏轼    |       李太白  | 纳兰性德 || 水调歌头 | 梦游天姥吟留别 |   饮水词 |</code></pre><table><thead><tr><th align="left">left</th><th align="center">center</th><th align="right">right</th></tr></thead><tbody><tr><td align="left">苏轼</td><td align="center">李太白</td><td align="right">纳兰性德</td></tr><tr><td align="left">水调歌头</td><td align="center">梦游天姥吟留别</td><td align="right">饮水词</td></tr></tbody></table><blockquote><p>如果不使用对齐标记，单元格中的内容默认左对齐；表头单元格中的内容会一直居中对齐（不同的实现可能会有不同表现）。</p></blockquote><h3 id="表格和基础语法结合"><a href="#表格和基础语法结合" class="headerlink" title="表格和基础语法结合"></a>表格和基础语法结合</h3><pre><code>name | link---  | ---*百度* | [百度](www.baidu.com)**谷歌** | [谷歌](www.google.com)    </code></pre><table><thead><tr><th>name</th><th>link</th></tr></thead><tbody><tr><td><em>百度</em></td><td><a href="www.baidu.com">百度</a></td></tr><tr><td><strong>谷歌</strong></td><td><a href="www.google.com">谷歌</a></td></tr></tbody></table><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><ul><li>尚未完成的任务，文本行以<code>-[ ]</code>开头</li><li>已经完成的任务，文本行以<code>-[x]</code>开头</li></ul><pre><code>- [ ] 尚未开始的任务- [x] 已经完成的任务</code></pre><ul><li> 尚未开始的任务</li><li> 已经完成的任务</li></ul><h2 id="锚"><a href="#锚" class="headerlink" title="锚"></a>锚</h2><p>　锚是一种特殊的链接，专门用以标志出可供跳转到位置。 　</p><blockquote><p>注意：由于标题可以折叠其下的内容，所以锚可能被它前面的标题折叠起来。此时锚是不起作用的。</p></blockquote><p>示例：在指定位置添加：</p><pre><code>&lt;a id=&quot;jump&quot;&gt;我是锚点&lt;/a&gt;</code></pre><p>然后此处添加：</p><pre><code>[跳转锚点](#jump)</code></pre><p><a href="#jump">跳转锚点</a></p><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>格式为:<br>在代码块的符号后面直接加语言 如java</p><pre><code>window.addEventListener(&#39;load&#39;, function() &#123;  console.log(&#39;window loaded&#39;);&#125;);</code></pre><center>-----本文结束啦感谢您的阅读-----]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/posts/5d36ff15/"/>
      <url>/posts/5d36ff15/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><h1 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h1><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。</p><p><a href="https://markdown-zh.readthedocs.io/en/latest/">官网</a></p><h1 id="Markdown基本语法介绍"><a href="#Markdown基本语法介绍" class="headerlink" title="Markdown基本语法介绍"></a>Markdown基本语法介绍</h1><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><strong>Html</strong> 中通常使用<code>&lt;H1&gt;-&lt;H6&gt;</code>这六种标签对来表示六级标题，所以在 Markdown 标准语法中也定义了标题。Markdown 语法中，标题有两种：<strong>Atx</strong> 方式和 <strong>Setext</strong> 方式。但是<strong>Setext</strong>方式在实现折叠功能时易导致冲突，且易和水平线相混淆。故而本文只介绍 <strong>Atx</strong> 方式。</p><p><strong>Atx 方式的标题：</strong>以#符开头，共六级，一级就以一个#开头，二级就以两个#开头（写成##），其余依此类推。</p><p><strong>实例如下：</strong></p><pre><code>#我是一级标题 ##我是二级标题 ###我是三级标题 ####我是四级标题 #####我是五级标题 ######我是六级标题</code></pre><h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><p>在标准 Markdown 中，一行由三个以上连续的减号组成的文本会被视为水平线。有些编辑器也支持星号符（*）和下划线字符（_）。</p><p>有空格的减号的水平线：</p><hr><p>没空格的减号的水平线：</p><hr><p><code>*</code>号的水平线:</p><hr><p>下划线的水平线:</p><hr><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><p><strong>斜体效果</strong>是在需要斜体的文字<strong>前后</strong>加一个*</p><pre><code>*斜体*</code></pre><p>效果：<em>我是斜体</em></p><h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><p><strong>加粗效果</strong>是在需要加粗的文字<strong>前后</strong>各加两个**或各两个_（下划线符）</p><pre><code>**加粗**/__加粗__</code></pre><p>效果：</p><p>*号的加粗： <strong>加粗</strong></p><p>_号的加粗： <strong>加粗</strong></p><h2 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h2><p><strong>斜体加粗效果</strong>是在需要斜体加粗的文字前后各加***</p><pre><code>***斜体加粗***</code></pre><p>效果：*<strong>斜体加粗*</strong></p><h2 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h2><p>块引用一般用于注释。<br>Markdown 标记区块引用和 email 中用 『&gt;』的引用方式类似，只需要在整个段落的第一行最前面加上 『&gt;』</p><blockquote><p>我是引用</p></blockquote><p>区块引用可以嵌套，只要根据层次加上不同数量的『&gt;』：</p><blockquote><p>我是一级引用</p><blockquote><p>我是二级引用</p><blockquote><p>我是三级引用</p></blockquote><p>返回二级引用</p></blockquote><p>返回一级引用</p></blockquote><p>注：返回上级引用，中间应回车加上一级的『&gt;』数量</p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块用以呈现须原样输出的文本。代码块有两种，一种在行内（即行内代码块），另一种可以跨行（即多行代码块）。行内代码块编译后会被 Html 的 <code>&lt;code&gt;&lt;/code&gt;</code>标签对包围；而跨行代码块会被编译到<code>&lt;pre&gt;&lt;code&gt;&lt;/pre&gt;&lt;/code&gt;</code>标签对中。</p><h3 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h3><p>行内代码块以两个`字符包围</p><p>如：<code>我是代码块</code></p><h3 id="多行代码块"><a href="#多行代码块" class="headerlink" title="多行代码块"></a>多行代码块</h3><p>每行都需要以至少四个半角空格（或以至少一个Tab符）开头.</p><p><strong>实例：</strong></p><p>□□□□function DeleteText()□□<br>□□□□{□□<br>□□□□□□□□string s = “示例文本”;□□<br>□□□□□□□□…□□<br>□□□□□□□□ClipBoard.Delete();□□<br>□□□□}□□<br>[Tab]function DeleteImage()□□<br>[Tab]{□□<br>[Tab][Tab]Image img = new Image();□□<br>[Tab][Tab]…□□<br>[Tab][Tab]ClipBoard.Delete();□□<br>[Tab]}□□</p><p>转译后：</p><pre><code>function DeleteText()&#123;  string s = &quot;示例文本&quot;;  ...  ClipBoard.Delete();  &#125; function DeleteImage()  &#123;   Image img = new Image();   ...   ClipBoard.Delete();  &#125; </code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表有两种：无序列表、有序列表。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>　以<code>-</code>、<code>+</code>、<code>*</code>这三个字符开头的行是无序列表项。这三个字符使用任意一个字符都可以，编译后的结果是一样的。</p><p>　注：使用<code>*</code>作为列表开头会与加粗、倾斜这两种效果冲突，所以尽可能不要用！！！如果实在必须在一行开头使用<code>*</code>来表示无序列表，要注意必须在后面跟一个空格（全、半角均可）,或者格式化一下。<br>如：</p><p><code>+</code>无序列表</p><ul><li>无序列表</li></ul><p><code>-</code>无序列表</p><ul><li>无序列表</li></ul><p><code>*</code>无序列表</p><ul><li>无序列表</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><pre><code>1. 有序列表以数字和 `.` 开始；3. 数字的序列并不会影响生成的列表序列；4. 但仍然推荐按照自然顺序（1.2.3...）编写。</code></pre><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><pre><code>1. 第一层    + 第二层        1. 第三层2. 第一层    1. 第二层        - 第三层</code></pre><ol><li>第一层<ul><li>第二层<ol><li>第三层</li></ol></li></ul></li><li>第一层<ol><li>第二层<ul><li>第三层</li></ul></li></ol></li></ol><p>注：</p><ol><li><p>记得数字或符号<code>.</code>后加空格</p></li><li><p>如仅需显示数字和<code>.</code>,需<code>\</code>来进行对<code>.</code>进行转义.如：<code>1\.</code></p></li></ol><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>格式为 <code>[link text](URL &#39;title text&#39;)</code>。</p><ol><li>普通链接：</li></ol><p><a href="http://www.google.com/">Google</a></p><pre><code>[Google](http://www.google.com/)</code></pre><ol start="2"><li>指向本地文件的链接：</li></ol><p><a href="./images/icon.png">icon.png</a></p><pre><code>[icon.png](./images/icon.png)</code></pre><ol start="3"><li>包含 ‘title’ 的链接:</li></ol><p><a href="http://www.google.com/">Google</a></p><pre><code>[Google](http://www.google.com/ &quot;Google&quot;)</code></pre><blockquote><p>title 使用 ‘ 或 “ 都是可以的。</p></blockquote><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>参考式链接的写法相当于行内式拆分成两部分，并通过一个 识别符 来连接两部分。参考式能尽量保持文章结构的简单，也方便统一管理 URL。</p><p>1.定义链接：</p><pre><code>[Google][link]</code></pre><p>第二个方括号内为链接独有的 识别符，可以是字母、数字、空白或标点符号。识别符是 不区分大小写 的；</p><p>2.定义链接内容:</p><pre><code>[link]: http://www.google.com/ &quot;Google&quot;</code></pre><p>其格式为：[识别符]: URL ‘title’。</p><blockquote><p>其中，URL可以使用 &lt;&gt; 包括起来，title 可以使用 “”、’’、() 包括（考虑到兼容性，建议使用引号），title 部分也可以换行来写；</p></blockquote><blockquote><p>链接内容的定义可以放在同一个文件的 任意位置；</p></blockquote><p>3.也可以省略 识别符，使用链接文本作为 识别符：</p><pre><code>[Google][][Google]: http://www.google.com/ &quot;Google&quot;</code></pre><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>使用 &lt;&gt; 包括的 URL 或邮箱地址会被自动转换为超链接：</p><pre><code>&lt;http://www.google.com/&gt;</code></pre><p><a href="http://www.google.com/">http://www.google.com/</a></p><h3 id="图像超链接"><a href="#图像超链接" class="headerlink" title="图像超链接"></a>图像超链接</h3><pre><code>![找不到图像文件时显示的文本](图像路径)</code></pre><blockquote><p>比文字超链接也就多个惊叹号。</p></blockquote><center>-----本文结束啦感谢您的阅读-----]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android studio插件</title>
      <link href="/posts/8818babb/"/>
      <url>/posts/8818babb/</url>
      
        <content type="html"><![CDATA[<h1 id="本文只要介绍Android-studio常用的几款插件（持续更新）。"><a href="#本文只要介绍Android-studio常用的几款插件（持续更新）。" class="headerlink" title="本文只要介绍Android studio常用的几款插件（持续更新）。"></a>本文只要介绍Android studio常用的几款插件（持续更新）。</h1><span id="more"></span><ol><li>CodeGlance</li></ol><p>此插件在你的编辑器中嵌入了代码的<code>缩略图</code></p><ol start="2"><li>Rainbow Brackets</li></ol><p>这个插件为您的代码添加了漂亮的彩虹色，用于圆括号，方括号和大括号。</p><ol start="3"><li>ADB Idea</li></ol><p>ADB Idea提供了单击快捷方式命令，用于启动，卸载，终止应用程序，撤消权限以及清除应用程序数据。</p><ol start="4"><li>ADB Wifi</li></ol><p>确保你的电脑和手机连接在同一网络上，然后转到<code>“Tools”→“ android”→“ ADB WIFI”→“ ADB USB to WIFI”</code>开始连接，现在您无需USB连接，即可运行应用程序。</p><ol start="5"><li>Material UI Theme</li><li>JSON To Kotlin Class</li><li>Codota</li></ol><p>Codota是一个基于AI的代码补全插件，它使用机器学习数百万个代码段（Java，Javascript，Python等），根据您的上下文建议补全代码。它还使你可以直接嵌入通用代码段，以提高开发技能并减少出错的机会。</p><ol start="8"><li>Name That Color</li></ol><p>最匹配的 material颜色调色板名称</p><ol start="9"><li> Key Promoter X</li></ol><p>这是一个IntelliJ IDE插件，可帮助你在工作时学习基本的快捷方式。</p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> plugins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora常用快捷键</title>
      <link href="/posts/12a67745/"/>
      <url>/posts/12a67745/</url>
      
        <content type="html"><![CDATA[<h1 id="本文只要介绍Typora常用快捷键（持续更新）。"><a href="#本文只要介绍Typora常用快捷键（持续更新）。" class="headerlink" title="本文只要介绍Typora常用快捷键（持续更新）。"></a>本文只要介绍Typora常用快捷键（持续更新）。</h1><span id="more"></span><h1 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h1><h2 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h2><p><strong>a markdown editor,markdown reader.</strong></p><h2 id="为什么选择Typora"><a href="#为什么选择Typora" class="headerlink" title="为什么选择Typora"></a>为什么选择Typora</h2><ol><li>轻便简洁</li><li>即时渲染</li><li>可读性强</li><li>学习成本低</li><li>个人习惯：能和开源笔记Joplin结合使用</li><li><del>Free</del>(2021/12/01正式版开始收费)</li></ol><h2 id="与常用markdown语法的区别"><a href="#与常用markdown语法的区别" class="headerlink" title="与常用markdown语法的区别"></a>与常用markdown语法的区别</h2><ol><li>标题、字体等语法支持快捷键</li><li>支持更多的文字格式，可在偏好设置进行设置</li><li>支持更多的对齐方式，如“<center>”进行居中</li></ol><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul><li>加粗 Cmd+B</li><li>标题 <code>Cmd+数字</code> 如一级标题 <code>Cmd+1</code></li><li>插入链接 <code>Cmd+K</code></li><li>代码块 <code>Cmd+option+C</code></li><li>表格 <code>option + Cmd + T</code></li><li>引用 <code>option + Cmd + Q</code></li><li>水平分割线：<code>shift + Cmd + -</code></li><li>斜体 <code>Cmd + I</code></li><li>删除线 <code>control + ~</code></li><li>注释 <code>control + -</code></li><li>显示/隐藏侧边栏 <code>shift + Cmd + L</code></li><li>大纲视图 <code>control + Cmd + 1</code></li><li>文档列表视图 <code>control + Cmd +2</code></li><li>文件树视图：<code>control + Cmd + 3</code></li><li>链接引用 <code>option + Cmd + L</code></li><li>脚注 <code>option + Cmd + R</code></li><li>代码高亮 “`”+回车 选择语言</li><li>下标 H<del>2</del>o</li><li>上标 x^2^</li><li>==高亮==</li><li>目录（TOC）输入[toc] 然后回车，即可创建一个“目录”，TOC从文档中提取所有的标题，其内容将自动更新。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/cf83d2887ea1">typora快捷键使用</a></p><p><a href="https://sspai.com/post/54912">Typora完全使用详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iTerm2配置和美化</title>
      <link href="/posts/d2a06635/"/>
      <url>/posts/d2a06635/</url>
      
        <content type="html"><![CDATA[<h1 id="本文只要介绍iTerm2在mac-OS上的配置和美化。"><a href="#本文只要介绍iTerm2在mac-OS上的配置和美化。" class="headerlink" title="本文只要介绍iTerm2在mac OS上的配置和美化。"></a>本文只要介绍iTerm2在mac OS上的配置和美化。</h1><span id="more"></span><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>iTerm2</code>是<code>macOS</code>平台上终端的替代方案，功能也更强大</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://iterm2.com/">iTerm2官网</a></p><h3 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h3><pre><code>iTerm2 -&gt; Make ITerm2 Default Term</code></pre><h3 id="设置透明度"><a href="#设置透明度" class="headerlink" title="设置透明度"></a>设置透明度</h3><pre><code>iTerm -&gt; Preferences -&gt; Profiles -&gt; window -&gt; Transparency</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li><p>设置默认shell为zsh</p><ul><li><p>查看系统所有shell列表</p><pre><code>cat /etc/shells</code></pre></li><li><p>查看zsh版本</p><pre><code>zsh --version</code></pre></li><li><p>设置默认 shell 为 zsh，它功能比较多，会好使一些。</p><pre><code>chsh -s /bin/zsh</code></pre></li></ul></li><li><p>安装oh-my-zsh</p><ul><li><p>什么是oh-my-zsh</p><blockquote><p>oh-my-zsh 是一款社区驱动的命令行工具，它基于 zsh 命令行，提供了主题配置，插件机制，大大提高了可玩（用）性。</p></blockquote></li><li><p>下载地址</p><p><a href="https://github.com/ohmyzsh/ohmyzsh">oh-my-zsh</a></p></li><li><p>安装</p><p><strong>以下脚本执行一个</strong>：</p><ul><li><p>wget：</p><pre><code>export REMOTE=https://gitee.com/imirror/ohmyzsh.gitsh -c &quot;$(wget -O- https://cdn.jsdelivr.net/gh/ohmyzsh/ohmyzsh/tools/install.sh)&quot;</code></pre></li><li><p>fetch：</p><pre><code>export REMOTE=https://gitee.com/imirror/ohmyzsh.gitsh -c &quot;$(fetch -o - https://cdn.jsdelivr.net/gh/ohmyzsh/ohmyzsh/tools/install.sh)&quot;</code></pre></li><li><p>curl：</p></li></ul><pre><code>export REMOTE=https://gitee.com/imirror/ohmyzsh.gitsh -c &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ohmyzsh/ohmyzsh/tools/install.sh)&quot;</code></pre></li></ul></li><li><p>配置zsh主题</p><ul><li><p>官方主题</p><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">主题</a></p></li><li><p>vim打开<code>~/.zshrc</code>文件</p><pre><code>vim ~/.zshrc</code></pre></li><li><p>更改ZSH_THEME字段为你所选的主题名称</p></li></ul></li><li><p>更改字体</p></li></ol><pre><code class="iTerm">iTerm -&gt; Preferences -&gt; Profiles -&gt; Text</code></pre><ol start="5"><li>功能增强</li></ol><ul><li>5.1 命令自动补全功能</li></ul><p>​    克隆代码到<code>$ZSH_CUSTOM/plugins</code>（默认位于<code>~/.oh-my-zsh/custom/plugins</code>）</p><pre><code>git clone https://gitee.com/imirror/zsh-autosuggestions.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</code></pre><ul><li>5.1.1执行zshrc文件</li></ul><pre><code>source ~/.zshrc</code></pre><ul><li>5.1.2配置插件</li></ul><p>打开<code>~/.zshrc</code>，找到<code>plugins</code>，追加<code>zsh-autosuggestions</code>。</p><ul><li><p>5.2 语法高亮</p></li><li><p>5.21.克隆代码到<code>$ZSH_CUSTOM/plugins</code>（默认位于<code>~/.oh-my-zsh/custom/plugins</code>）</p></li></ul><pre><code>git clone https://gitee.com/imirror/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</code></pre><ul><li>5.2.2 配置启用插件</li></ul><p>打开<code>~/.zshrc</code>，找到<code>plugins</code>，追加<code>zsh-autosuggestions</code>。</p><ul><li>5.2.3执行zshrc文件</li></ul><pre><code>source ~/.zshrc</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> itrem2 zsh </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>性别：男 </p><p>爱好：女</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
