<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Evan`s Blog</title>
  
  
  <link href="https://blog.popperevan.work/atom.xml" rel="self"/>
  
  <link href="https://blog.popperevan.work/"/>
  <updated>2021-12-02T17:20:47.243Z</updated>
  <id>https://blog.popperevan.work/</id>
  
  <author>
    <name>Evan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OkHttp基本应用</title>
    <link href="https://blog.popperevan.work/posts/88a80a38/"/>
    <id>https://blog.popperevan.work/posts/88a80a38/</id>
    <published>2020-12-02T17:17:29.000Z</published>
    <updated>2021-12-02T17:20:47.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OkHttp基本使用"><a href="#OkHttp基本使用" class="headerlink" title="OkHttp基本使用"></a>OkHttp基本使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    OkHttp 是一款高效的HTTP客户端，支持连接同一地址的链接共享同一个socket，通过连接池减小响应延迟，GZIP压缩，请求缓存等优势，核心主要有路由，连接协议，拦截器，代理，安全性认证，连接池以及网络适配。</p><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://square.github.io/okhttp/">官网地址</a></p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><p>先上代码：</p><ol><li><p>get同步请求</p><pre><code class="java">   public static void getByExecute()&#123;        //创建客户端        OkHttpClient client=new OkHttpClient();        //url        String url = &quot;https://www.baidu.com/&quot;;        //创建请求封装类（默认是get请求故可以不加）        Request request = new Builder()                .url(url)                .build();        //创建发送请求类        Call call=client.newCall(request);        // 同步请求要在子线程中开启        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    //创建请求响应封装类                    Response response = call.execute();                    Log.e(TAG, &quot;okHttpGet run: response:&quot;+ response.body().string());                &#125; catch (IOException e) &#123;                    e.printStackTrace();                    Log.e(TAG,e.getMessage());                &#125;            &#125;        &#125;).start();    &#125;</code></pre></li><li><p>get异步请求</p></li></ol><pre><code class="java"> public static void getByEnqueue()&#123;        //第二种创建client的方法        OkHttpClient okHttpClient = new OkHttpClient.Builder().build();        String url = &quot;https://www.baidu.com/&quot;;        Request request = new Builder().url(url).build();        Call call=okHttpClient.newCall(request);        call.enqueue(new Callback() &#123;            @Override            public void onFailure(Call call, IOException e) &#123;                Log.e(TAG, &quot;okHttpGet run: response:&quot;+ &quot;onFailure&quot; +e.getMessage());            &#125;            @Override            public void onResponse(Call call, Response response) throws IOException &#123;                Log.e(TAG, &quot;okHttpGet run: response:&quot;+ response.code());                Log.e(TAG, &quot;okHttpGet run: response:&quot;+ response.body().string());            &#125;        &#125;);    &#125;</code></pre><p>从上述代码咱们来入手分析下：</p><ol><li><p>okhttp的get请求分为同步和异步两种请求方式</p></li><li><p>创建客户端（直接new的方法和调用builder的方法进行创建，其实在new方法的内部也是调用builder的方式，但是不能添加拦截器、超时参数、log日志、头文件、缓存等属性）</p></li><li><p>创建请求封装类（okhttp默认是get请求故可不加get()）</p></li><li><p>创建发送请求类</p></li><li><p>根据需求调用同步/异步请求方法</p></li></ol><blockquote><p>需要注意的是同步的方法会阻塞线程，需要开启子线程进行调用</p><p>异步调用的回调函数是在子线程，不能进行更新UI等操作，需要<code>runOnUiThread()</code>方法或者<code>Handler</code>来处理</p></blockquote><h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><p>​    <strong>post</strong>请求需要在<strong>Request</strong>传递一个<strong>RequestBody</strong>作为post的参数，<strong>RequestBody</strong>有两个子类：<strong>FormBody</strong>和<strong>MultipartBody</strong></p><ol><li>json数据提交</li></ol><pre><code class="java">public static void postByJson(String json)&#123;    //创建客户端    OkHttpClient okHttpClient = new OkHttpClient.Builder().build();      //创建json      public static final MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;);    //创建RequestBody    RequestBody body = RequestBody.create(JSON, json);    //创建请求封装类    Request request = new Request.Builder()            .url(&quot;http://www.jianshu.com/&quot;)            .post(body)            .build();    //创建发送请求类    Call call = okHttpClient.newCall(request);    //发送请求    call.enqueue(new Callback() &#123;        @Override        public void onFailure(Call call, IOException e) &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ &quot;onFailure&quot; +e.getMessage());        &#125;        @Override        public void onResponse(Call call, Response response) throws IOException &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ response.code());        &#125;    &#125;);&#125;</code></pre><ol start="2"><li>表单提交</li></ol><p>FromBody用于提交表单键值对</p><pre><code class="java">public static void postByFormBody()&#123;    //创建客户端    OkHttpClient okHttpClient = new OkHttpClient.Builder().build();    //创建form表单    FormBody formBody = new FormBody.Builder()            .add(&quot;username&quot;, &quot;admin&quot;)            .add(&quot;password&quot;, &quot;admin&quot;)            .build();    //创建请求封装类    Request request = new Request.Builder()            .url(&quot;http://www.jianshu.com/&quot;)            .post(formBody)            .build();    //创建发送请求类    Call call = okHttpClient.newCall(request);    //发送请求    call.enqueue(new Callback() &#123;        @Override        public void onFailure(Call call, IOException e) &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ &quot;onFailure&quot; +e.getMessage());        &#125;        @Override        public void onResponse(Call call, Response response) throws IOException &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ response.code());        &#125;    &#125;);&#125;</code></pre><p>当然这是最简单的表单提交直接在Formbody对象创建的过程中add API所需的params。我们在实际工作中肯定不会这样来做，不仅代码冗余而且扩展性太差，我们不能每个借口都初始化一边Formbody对象，然后一个个的add。我们肯定是传递params的方式来做。这里给大家演示下：</p><pre><code class="java">public static void postByFormBody(String userName,String password )&#123;    //创建客户端    OkHttpClient okHttpClient = new OkHttpClient.Builder().build();    //创建hashmap    HashMap&lt;String,String&gt; paramsMap=new HashMap&lt;&gt;();    paramsMap.put(&quot;username&quot;,userName);    paramsMap.put(&quot;password&quot;,password);    //创建form表单    FormBody.Builder builder = new FormBody.Builder();    for (String key : paramsMap.keySet()) &#123;        //追加表单信息        builder.add(key, paramsMap.get(key));    &#125;    RequestBody formBody=builder.build();    //创建请求封装类    Request request = new Request.Builder()            .url(&quot;http://www.jianshu.com/&quot;)            .post(formBody)            .build();    //创建发送请求类    Call call = okHttpClient.newCall(request);    //发送请求    call.enqueue(new Callback() &#123;        @Override        public void onFailure(Call call, IOException e) &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ &quot;onFailure&quot; +e.getMessage());        &#125;        @Override        public void onResponse(Call call, Response response) throws IOException &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ response.code());        &#125;    &#125;);&#125;</code></pre><p>看完之后，你要说了这样写也没少写多少代码，也没看到代码的优雅之处呀。别急！，这里就要给大家说了我们这里之所以使用<strong>HashMap</strong>这样的数据结构，优点在于他的查找速度为O(1),很快。但是哈，对于我们工作中的API来说，其实没有那么多的params的，这里的优势也体现不出来。并且<strong>HashMap</strong>消耗内存比较大。所以这里在params少的情况下不太提倡，而且我们经常传参数都是用的JAVA bean的形式。所以这里给出我们常用的调用方式：</p><ol><li>首先我们新建一个bean</li></ol><pre><code class="java">public class RequestBean implements Serializable&#123;    private String name;    private String value;    public RequestBean(String name, String value) &#123;        this.name = name;        this.value = value;    &#125;    public String name() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getValue() &#123;        return value;    &#125;    public void setValue(String value) &#123;        this.value = value;    &#125;&#125;</code></pre><ol start="2"><li>调用</li></ol><pre><code class="java">public static void postByFormBody()&#123;    //创建客户端    OkHttpClient okHttpClient = new OkHttpClient.Builder().build();    //创建一个FormBody.Builder    FormBody.Builder builder=new FormBody.Builder();      //创建list    List&lt;RequestBean&gt;beans=new ArrayList&lt;&gt;();      beans.add(new RequestBean(&quot;userName&quot;,&quot;admin&quot;));    beans.add(new RequestBean(&quot;password&quot;,&quot;123456&quot;));       if (beans!=null&amp;&amp;beans.size()&gt;0)&#123;            for (final RequestBean p : beans) &#123;                builder.add(p.getName(),p.getValue());            &#125;        &#125;      //创建RequestBody    RequestBody formBody=builder.build();    //创建请求封装类    Request request = new Request.Builder()            .url(&quot;http://www.jianshu.com/&quot;)            .post(formBody)            .build();    //创建发送请求类    Call call = okHttpClient.newCall(request);    //发送请求    call.enqueue(new Callback() &#123;        @Override        public void onFailure(Call call, IOException e) &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ &quot;onFailure&quot; +e.getMessage());        &#125;        @Override        public void onResponse(Call call, Response response) throws IOException &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ response.code());        &#125;    &#125;);&#125;</code></pre><ol start="3"><li>文件上传</li></ol><p>MultipartBody可以构建与HTML文件上传格式兼容的复杂请求体。</p><p>此处以上传图片为例：</p><pre><code class="java">public static void postByFile()&#123;    //创建客户端    OkHttpClient okHttpClient = new OkHttpClient.Builder().build();    //创建一个file对象    File file = new File(&quot;File path&quot;);    //创建RequestBody     RequestBody requestBody = RequestBody.create(MediaType.parse(&quot;application/octet-stream&quot;), file);    //创建MultipartBody    MultipartBody multipartBody = new MultipartBody.Builder()            .setType(MultipartBody.FORM)            .addFormDataPart(&quot;param1&quot;, &quot;value1&quot;)            .addFormDataPart(&quot;param2&quot;, &quot;value2&quot;)            .addFormDataPart(&quot;param3&quot;, &quot;value3&quot;)            .addFormDataPart(&quot;pic&quot;, &quot;1.png&quot;, requestBody)            .build();    //创建请求封装类    Request request = new Request.Builder()            .url(&quot;http://www.jianshu.com/&quot;)            .post(multipartBody)            .build();    //创建发送请求类    Call call = okHttpClient.newCall(request);    //发送请求    call.enqueue(new Callback() &#123;        @Override        public void onFailure(Call call, IOException e) &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ &quot;onFailure&quot; +e.getMessage());        &#125;        @Override        public void onResponse(Call call, Response response) throws IOException &#123;            Log.e(TAG, &quot;okHttpPost run: response:&quot;+ response.code());        &#125;    &#125;);&#125;</code></pre><blockquote><p>文件依然是通过addFormDataPart进行添加，只不过多了一个RequestBody参数<br>将文件存放到RequestBody中，然后将该RequestBody添加到MultipartBody中，组成一个完整的RequestBody用于请求<br>“application/octet-stream”是以文件流方式传输，适合于所有文件，也可以使用指定的Content-Type进行传输，比如<code>&quot;application/x-png&quot;</code></p></blockquote><p>通过MultipartBody就可以轻松将文件上传至服务器，无需进行复杂的流操作，但是美中不足的是没有进度信息，如果文件较大的情况下，上传耗时比较久，只有文件完全上传后才有回调，十分不友好.</p><ol start="4"><li>文件上传进度</li></ol><p>OkHttp并没有提供进度的相关回调或者接口，但是POST都是通过RequestBody进行请求的，查看RequestBody类就可以发现RequestBody只有三个主要方法</p><pre><code class="java">/** Returns the Content-Type header for this body. */public abstract @Nullable MediaType contentType();/*** Returns the number of bytes that will be written to &#123;@code sink&#125; in a call to &#123;@link #writeTo&#125;, * or -1 if that count is unknown. */public long contentLength() throws IOException &#123;  return -1;&#125;/** Writes the content of this request to &#123;@code sink&#125;. */public abstract void writeTo(BufferedSink sink) throws IOException;</code></pre><p>根据注释可以明确各个方法的作用</p><ol><li>contentType() 返回Content-Type</li><li>contentLength() 返回已写入数据大小</li><li>writeTo 将数据写入BufferedSink</li></ol><p>RequestBody还提供了几个请求的实现，当上传文件的时候的实现方法：</p><pre><code class="java">/** Returns a new request body that transmits the content of &#123;@code file&#125;. */public static RequestBody create(final @Nullable MediaType contentType, final File file) &#123;  if (file == null) throw new NullPointerException(&quot;file == null&quot;);  return new RequestBody() &#123;    @Override public @Nullable MediaType contentType() &#123;      return contentType;    &#125;    @Override public long contentLength() &#123;      return file.length();    &#125;    @Override public void writeTo(BufferedSink sink) throws IOException &#123;      Source source = null;      try &#123;        source = Okio.source(file);        sink.writeAll(source);      &#125; finally &#123;        Util.closeQuietly(source);      &#125;    &#125;  &#125;;&#125;</code></pre><p>因此只要获取BufferedSink的大小就可以获取文件传输的大小，但是OkHttp提供的方法中是将文件通过writeAll()进行写入的，无法确定每个时间段具体传输了多少，继续查看writeAll()</p><pre><code class="java">@Override public long writeAll(Source source) throws IOException &#123;    if (source == null) throw new IllegalArgumentException(&quot;source == null&quot;);    long totalBytesRead = 0;    for (long readCount; (readCount = source.read(this, Segment.SIZE)) != -1; ) &#123;      totalBytesRead += readCount;    &#125;    return totalBytesRead;  &#125;</code></pre><p>到这就很明了了，writeAll每次写入的是Segment.SIZE(8192)字节，我们只要将writeAll提取出来就可以自己控制上传的进度了</p><pre><code class="java">public class FileRequestBody extends RequestBody &#123;    private RequestBody mRequestBody;    private long mContentLength;    private LoadingListener mLoadingListener;    public FileRequestBody(RequestBody requestBody, LoadingListener loadingListener) &#123;        mRequestBody = requestBody;        mLoadingListener = loadingListener;    &#125;    //文件的总长度    @Override    public long contentLength() &#123;        try &#123;            if (mContentLength == 0)                mContentLength = mRequestBody.contentLength();            return mContentLength;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return -1;    &#125;    @Override    public MediaType contentType() &#123;        return mRequestBody.contentType();    &#125;    @Override    public void writeTo(BufferedSink sink) throws IOException &#123;        ByteSink byteSink = new ByteSink(sink);        BufferedSink mBufferedSink = Okio.buffer(byteSink);        mRequestBody.writeTo(mBufferedSink);        mBufferedSink.flush();    &#125;    private final class ByteSink extends ForwardingSink &#123;        //已经上传的长度        private long mByteLength = 0L;        ByteSink(Sink delegate) &#123;            super(delegate);        &#125;        @Override        public void write(Buffer source, long byteCount) throws IOException &#123;            super.write(source, byteCount);            mByteLength += byteCount;            mLoadingListener.onProgress(mByteLength, contentLength());        &#125;    &#125;    public interface LoadingListener &#123;        void onProgress(long currentLength, long contentLength);    &#125;&#125;</code></pre><p>调用的时候也只需要将</p><pre><code class="java">RequestBody requestBody = RequestBody.create(MediaType.parse(&quot;application/octet-stream&quot;), file);</code></pre><p>替换成</p><pre><code class="java">RequestBody requestBody = new FileRequestBody(MediaType.parse(&quot;application/octet-stream&quot;), file);</code></pre><ol start="5"><li><p>图片下载，文件下载</p><p>图片下载是通过回调的Response拿到byte[]然后decode成图片；<br>文件下载，就是拿到inputStream做写文件操作；</p></li><li><p>请求回调</p></li></ol><p>同步请求：</p><pre><code class="java">Response response = call.execute();</code></pre><p>异步请求是在onResponse回调中</p><p>同样都会拿到一个<strong>Response</strong>对象：</p><pre><code class="java">//请求响应数据ResponseBody对象response.body();//请求响应的code 如成功200 response.code();//请求响应的header信息response.headers();</code></pre><p>数据处理：</p><pre><code class="java">//请求响应数据处理response.body().string();response.body().bytes();response.body().charStream();response.body().byteStream();</code></pre><p>okhttp会返回以上几种常用格式的响应数据，可根据业务的具体需求对数据进行格式化。</p><h3 id="最后来个流程图"><a href="#最后来个流程图" class="headerlink" title="最后来个流程图"></a>最后来个流程图</h3><p><img src="https://cdn.jsdelivr.net/gh/evan0929/picture/img/%E6%88%AA%E5%B1%8F2021-12-02%20%E4%B8%8B%E5%8D%8811.34.19-20211203011800461.png" alt="截屏2021-12-02 下午11.34.19"></p><center> -----本文结束啦感谢您的阅读-----]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OkHttp基本使用&quot;&gt;&lt;a href=&quot;#OkHttp基本使用&quot; class=&quot;headerlink&quot; title=&quot;OkHttp基本使用&quot;&gt;&lt;/a&gt;OkHttp基本使用&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="android" scheme="https://blog.popperevan.work/categories/android/"/>
    
    
    <category term="android" scheme="https://blog.popperevan.work/tags/android/"/>
    
    <category term="OkHttp" scheme="https://blog.popperevan.work/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>RxJava从入门到放弃（一）</title>
    <link href="https://blog.popperevan.work/posts/d717c770/"/>
    <id>https://blog.popperevan.work/posts/d717c770/</id>
    <published>2020-12-02T13:23:55.000Z</published>
    <updated>2021-12-02T13:45:48.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本系列文章介绍RxJava库在Android上的使用和源码分析。"><a href="#本系列文章介绍RxJava库在Android上的使用和源码分析。" class="headerlink" title="本系列文章介绍RxJava库在Android上的使用和源码分析。"></a>本系列文章介绍RxJava库在Android上的使用和源码分析。</h1><h1 id="本文只要介绍RxJava库在Android上的基本使用。"><a href="#本文只要介绍RxJava库在Android上的基本使用。" class="headerlink" title="本文只要介绍RxJava库在Android上的基本使用。"></a>本文只要介绍RxJava库在Android上的基本使用。</h1><span id="more"></span><h1 id="什么是RxJava"><a href="#什么是RxJava" class="headerlink" title="什么是RxJava"></a>什么是RxJava</h1><p>​    RxJava的官方介绍：</p><pre><code>a library for composing asynchronous and event-based programs using observable sequences for the Java VM</code></pre><p>​    中文意思就是:一个<strong>库，</strong>一个什么样子的库呢。在<code>Java VM</code>上使用可观测的序列来组成<strong>异步的</strong>、<strong>基于事件</strong>的程序的库。那么为什么叫<code>Rx</code>？<code>Rx</code>全称为<code>ReactiveX(Reactive Extensions)</code>。什么又叫做<code>Rx</code>,<br>这是一个使用<strong>可观察数据流</strong>进行<strong>异步编程</strong>的<strong>编程接口</strong>，是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的进行异步和基于事件的程序。</p><p>​    <a href="https://github.com/ReactiveX/RxJava">RxJava项目地址</a></p><center>-----本文结束啦感谢您的阅读-----]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;本系列文章介绍RxJava库在Android上的使用和源码分析。&quot;&gt;&lt;a href=&quot;#本系列文章介绍RxJava库在Android上的使用和源码分析。&quot; class=&quot;headerlink&quot; title=&quot;本系列文章介绍RxJava库在Android上的使用和源码分析。&quot;&gt;&lt;/a&gt;本系列文章介绍RxJava库在Android上的使用和源码分析。&lt;/h1&gt;&lt;h1 id=&quot;本文只要介绍RxJava库在Android上的基本使用。&quot;&gt;&lt;a href=&quot;#本文只要介绍RxJava库在Android上的基本使用。&quot; class=&quot;headerlink&quot; title=&quot;本文只要介绍RxJava库在Android上的基本使用。&quot;&gt;&lt;/a&gt;本文只要介绍RxJava库在Android上的基本使用。&lt;/h1&gt;</summary>
    
    
    
    <category term="android" scheme="https://blog.popperevan.work/categories/android/"/>
    
    
    <category term="android" scheme="https://blog.popperevan.work/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Markdown扩展语法</title>
    <link href="https://blog.popperevan.work/posts/c677b245/"/>
    <id>https://blog.popperevan.work/posts/c677b245/</id>
    <published>2018-11-22T16:00:00.000Z</published>
    <updated>2021-12-02T14:16:21.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown扩展语法"><a href="#Markdown扩展语法" class="headerlink" title="Markdown扩展语法"></a>Markdown扩展语法</h1><p>在<a href="https://blog.popperevan.work/posts/5d36ff15/">上一篇文章</a>,记录了Markdown的基本语法，本文记录下我们常用的扩展语法。</p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>当需要表示废弃的文字时或过时的方法，就需要删除线。加删除线的文本，在编译为 Html 后会被<code>&lt;s&gt;</code>和<code>&lt;/s&gt;</code>标签包围。<br>删除线的表现方法是：文字前后用<code>~~</code>包围。切记是半角<code>~</code>而非全角<code>～</code>，注意全角和半角的区别。</p><pre><code>~~要删除的方法~~</code></pre><p>效果：<del>要删除的文字</del></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>我是锚点</p><h3 id="单元格和表头"><a href="#单元格和表头" class="headerlink" title="单元格和表头"></a>单元格和表头</h3><p>使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行：</p><pre><code>姓名  | 代表作---- | ---苏轼  | 水调歌头纳兰性德 | 饮水词李太白 | 梦游天姥吟留别</code></pre><table><thead><tr><th>姓名</th><th>代表作</th></tr></thead><tbody><tr><td>苏轼</td><td>水调歌头</td></tr><tr><td>纳兰性德</td><td>饮水词</td></tr><tr><td>李太白</td><td>梦游天姥吟留别</td></tr></tbody></table><p>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界：</p><pre><code>| 姓名     |        代表作 || ----    | ------------ || 苏轼     |      水调歌头 || 纳兰性德 |        饮水词 || 李太白   | 梦游天姥吟留别 |</code></pre><table><thead><tr><th>姓名</th><th>代表作</th></tr></thead><tbody><tr><td>苏轼</td><td>水调歌头</td></tr><tr><td>纳兰性德</td><td>饮水词</td></tr><tr><td>李太白</td><td>梦游天姥吟留别</td></tr></tbody></table><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式：</p><ul><li><code>:---</code> 代表左对齐</li><li><code>:--:</code> 代表居中对齐</li><li><code>---:</code> 代表右对齐</li></ul><pre><code>| left    |      center | right   || :---    |      :--:   | ---:    || 苏轼    |       李太白  | 纳兰性德 || 水调歌头 | 梦游天姥吟留别 |   饮水词 |</code></pre><table><thead><tr><th align="left">left</th><th align="center">center</th><th align="right">right</th></tr></thead><tbody><tr><td align="left">苏轼</td><td align="center">李太白</td><td align="right">纳兰性德</td></tr><tr><td align="left">水调歌头</td><td align="center">梦游天姥吟留别</td><td align="right">饮水词</td></tr></tbody></table><blockquote><p>如果不使用对齐标记，单元格中的内容默认左对齐；表头单元格中的内容会一直居中对齐（不同的实现可能会有不同表现）。</p></blockquote><h3 id="表格和基础语法结合"><a href="#表格和基础语法结合" class="headerlink" title="表格和基础语法结合"></a>表格和基础语法结合</h3><pre><code>name | link---  | ---*百度* | [百度](www.baidu.com)**谷歌** | [谷歌](www.google.com)    </code></pre><table><thead><tr><th>name</th><th>link</th></tr></thead><tbody><tr><td><em>百度</em></td><td><a href="www.baidu.com">百度</a></td></tr><tr><td><strong>谷歌</strong></td><td><a href="www.google.com">谷歌</a></td></tr></tbody></table><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><ul><li>尚未完成的任务，文本行以<code>-[ ]</code>开头</li><li>已经完成的任务，文本行以<code>-[x]</code>开头</li></ul><pre><code>- [ ] 尚未开始的任务- [x] 已经完成的任务</code></pre><ul><li> 尚未开始的任务</li><li> 已经完成的任务</li></ul><h2 id="锚"><a href="#锚" class="headerlink" title="锚"></a>锚</h2><p>　锚是一种特殊的链接，专门用以标志出可供跳转到位置。 　</p><blockquote><p>注意：由于标题可以折叠其下的内容，所以锚可能被它前面的标题折叠起来。此时锚是不起作用的。</p></blockquote><p>示例：在指定位置添加：</p><pre><code>&lt;a id=&quot;jump&quot;&gt;我是锚点&lt;/a&gt;</code></pre><p>然后此处添加：</p><pre><code>[跳转锚点](#jump)</code></pre><p><a href="#jump">跳转锚点</a></p><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>格式为:<br>在代码块的符号后面直接加语言 如java</p><pre><code>window.addEventListener(&#39;load&#39;, function() &#123;  console.log(&#39;window loaded&#39;);&#125;);</code></pre><center>-----本文结束啦感谢您的阅读-----]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown扩展语法&quot;&gt;&lt;a href=&quot;#Markdown扩展语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown扩展语法&quot;&gt;&lt;/a&gt;Markdown扩展语法&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://blog.poppere</summary>
      
    
    
    
    <category term="工具" scheme="https://blog.popperevan.work/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="markdown" scheme="https://blog.popperevan.work/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="https://blog.popperevan.work/posts/5d36ff15/"/>
    <id>https://blog.popperevan.work/posts/5d36ff15/</id>
    <published>2018-11-22T16:00:00.000Z</published>
    <updated>2021-12-02T14:14:46.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><h1 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h1><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。</p><p><a href="https://markdown-zh.readthedocs.io/en/latest/">官网</a></p><h1 id="Markdown基本语法介绍"><a href="#Markdown基本语法介绍" class="headerlink" title="Markdown基本语法介绍"></a>Markdown基本语法介绍</h1><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><strong>Html</strong> 中通常使用<code>&lt;H1&gt;-&lt;H6&gt;</code>这六种标签对来表示六级标题，所以在 Markdown 标准语法中也定义了标题。Markdown 语法中，标题有两种：<strong>Atx</strong> 方式和 <strong>Setext</strong> 方式。但是<strong>Setext</strong>方式在实现折叠功能时易导致冲突，且易和水平线相混淆。故而本文只介绍 <strong>Atx</strong> 方式。</p><p><strong>Atx 方式的标题：</strong>以#符开头，共六级，一级就以一个#开头，二级就以两个#开头（写成##），其余依此类推。</p><p><strong>实例如下：</strong></p><pre><code>#我是一级标题 ##我是二级标题 ###我是三级标题 ####我是四级标题 #####我是五级标题 ######我是六级标题</code></pre><h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><p>在标准 Markdown 中，一行由三个以上连续的减号组成的文本会被视为水平线。有些编辑器也支持星号符（*）和下划线字符（_）。</p><p>有空格的减号的水平线：</p><hr><p>没空格的减号的水平线：</p><hr><p><code>*</code>号的水平线:</p><hr><p>下划线的水平线:</p><hr><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><p><strong>斜体效果</strong>是在需要斜体的文字<strong>前后</strong>加一个*</p><pre><code>*斜体*</code></pre><p>效果：<em>我是斜体</em></p><h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><p><strong>加粗效果</strong>是在需要加粗的文字<strong>前后</strong>各加两个**或各两个_（下划线符）</p><pre><code>**加粗**/__加粗__</code></pre><p>效果：</p><p>*号的加粗： <strong>加粗</strong></p><p>_号的加粗： <strong>加粗</strong></p><h2 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h2><p><strong>斜体加粗效果</strong>是在需要斜体加粗的文字前后各加***</p><pre><code>***斜体加粗***</code></pre><p>效果：*<strong>斜体加粗*</strong></p><h2 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h2><p>块引用一般用于注释。<br>Markdown 标记区块引用和 email 中用 『&gt;』的引用方式类似，只需要在整个段落的第一行最前面加上 『&gt;』</p><blockquote><p>我是引用</p></blockquote><p>区块引用可以嵌套，只要根据层次加上不同数量的『&gt;』：</p><blockquote><p>我是一级引用</p><blockquote><p>我是二级引用</p><blockquote><p>我是三级引用</p></blockquote><p>返回二级引用</p></blockquote><p>返回一级引用</p></blockquote><p>注：返回上级引用，中间应回车加上一级的『&gt;』数量</p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块用以呈现须原样输出的文本。代码块有两种，一种在行内（即行内代码块），另一种可以跨行（即多行代码块）。行内代码块编译后会被 Html 的 <code>&lt;code&gt;&lt;/code&gt;</code>标签对包围；而跨行代码块会被编译到<code>&lt;pre&gt;&lt;code&gt;&lt;/pre&gt;&lt;/code&gt;</code>标签对中。</p><h3 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h3><p>行内代码块以两个`字符包围</p><p>如：<code>我是代码块</code></p><h3 id="多行代码块"><a href="#多行代码块" class="headerlink" title="多行代码块"></a>多行代码块</h3><p>每行都需要以至少四个半角空格（或以至少一个Tab符）开头.</p><p><strong>实例：</strong></p><p>□□□□function DeleteText()□□<br>□□□□{□□<br>□□□□□□□□string s = “示例文本”;□□<br>□□□□□□□□…□□<br>□□□□□□□□ClipBoard.Delete();□□<br>□□□□}□□<br>[Tab]function DeleteImage()□□<br>[Tab]{□□<br>[Tab][Tab]Image img = new Image();□□<br>[Tab][Tab]…□□<br>[Tab][Tab]ClipBoard.Delete();□□<br>[Tab]}□□</p><p>转译后：</p><pre><code>function DeleteText()&#123;  string s = &quot;示例文本&quot;;  ...  ClipBoard.Delete();  &#125; function DeleteImage()  &#123;   Image img = new Image();   ...   ClipBoard.Delete();  &#125; </code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表有两种：无序列表、有序列表。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>　以<code>-</code>、<code>+</code>、<code>*</code>这三个字符开头的行是无序列表项。这三个字符使用任意一个字符都可以，编译后的结果是一样的。</p><p>　注：使用<code>*</code>作为列表开头会与加粗、倾斜这两种效果冲突，所以尽可能不要用！！！如果实在必须在一行开头使用<code>*</code>来表示无序列表，要注意必须在后面跟一个空格（全、半角均可）,或者格式化一下。<br>如：</p><p><code>+</code>无序列表</p><ul><li>无序列表</li></ul><p><code>-</code>无序列表</p><ul><li>无序列表</li></ul><p><code>*</code>无序列表</p><ul><li>无序列表</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><pre><code>1. 有序列表以数字和 `.` 开始；3. 数字的序列并不会影响生成的列表序列；4. 但仍然推荐按照自然顺序（1.2.3...）编写。</code></pre><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><pre><code>1. 第一层    + 第二层        1. 第三层2. 第一层    1. 第二层        - 第三层</code></pre><ol><li>第一层<ul><li>第二层<ol><li>第三层</li></ol></li></ul></li><li>第一层<ol><li>第二层<ul><li>第三层</li></ul></li></ol></li></ol><p>注：</p><ol><li><p>记得数字或符号<code>.</code>后加空格</p></li><li><p>如仅需显示数字和<code>.</code>,需<code>\</code>来进行对<code>.</code>进行转义.如：<code>1\.</code></p></li></ol><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>格式为 <code>[link text](URL &#39;title text&#39;)</code>。</p><ol><li>普通链接：</li></ol><p><a href="http://www.google.com/">Google</a></p><pre><code>[Google](http://www.google.com/)</code></pre><ol start="2"><li>指向本地文件的链接：</li></ol><p><a href="./images/icon.png">icon.png</a></p><pre><code>[icon.png](./images/icon.png)</code></pre><ol start="3"><li>包含 ‘title’ 的链接:</li></ol><p><a href="http://www.google.com/">Google</a></p><pre><code>[Google](http://www.google.com/ &quot;Google&quot;)</code></pre><blockquote><p>title 使用 ‘ 或 “ 都是可以的。</p></blockquote><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><p>参考式链接的写法相当于行内式拆分成两部分，并通过一个 识别符 来连接两部分。参考式能尽量保持文章结构的简单，也方便统一管理 URL。</p><p>1.定义链接：</p><pre><code>[Google][link]</code></pre><p>第二个方括号内为链接独有的 识别符，可以是字母、数字、空白或标点符号。识别符是 不区分大小写 的；</p><p>2.定义链接内容:</p><pre><code>[link]: http://www.google.com/ &quot;Google&quot;</code></pre><p>其格式为：[识别符]: URL ‘title’。</p><blockquote><p>其中，URL可以使用 &lt;&gt; 包括起来，title 可以使用 “”、’’、() 包括（考虑到兼容性，建议使用引号），title 部分也可以换行来写；</p></blockquote><blockquote><p>链接内容的定义可以放在同一个文件的 任意位置；</p></blockquote><p>3.也可以省略 识别符，使用链接文本作为 识别符：</p><pre><code>[Google][][Google]: http://www.google.com/ &quot;Google&quot;</code></pre><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>使用 &lt;&gt; 包括的 URL 或邮箱地址会被自动转换为超链接：</p><pre><code>&lt;http://www.google.com/&gt;</code></pre><p><a href="http://www.google.com/">http://www.google.com/</a></p><h3 id="图像超链接"><a href="#图像超链接" class="headerlink" title="图像超链接"></a>图像超链接</h3><pre><code>![找不到图像文件时显示的文本](图像路径)</code></pre><blockquote><p>比文字超链接也就多个惊叹号。</p></blockquote><center>-----本文结束啦感谢您的阅读-----]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown基本语法&quot;&gt;&lt;a href=&quot;#Markdown基本语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown基本语法&quot;&gt;&lt;/a&gt;Markdown基本语法&lt;/h1&gt;&lt;h1 id=&quot;Markdown简介&quot;&gt;&lt;a href=&quot;#Mar</summary>
      
    
    
    
    <category term="工具" scheme="https://blog.popperevan.work/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="markdown" scheme="https://blog.popperevan.work/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Android studio插件</title>
    <link href="https://blog.popperevan.work/posts/8818babb/"/>
    <id>https://blog.popperevan.work/posts/8818babb/</id>
    <published>2018-11-19T16:00:00.000Z</published>
    <updated>2021-11-29T18:43:13.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文只要介绍Android-studio常用的几款插件（持续更新）。"><a href="#本文只要介绍Android-studio常用的几款插件（持续更新）。" class="headerlink" title="本文只要介绍Android studio常用的几款插件（持续更新）。"></a>本文只要介绍Android studio常用的几款插件（持续更新）。</h1><span id="more"></span><ol><li>CodeGlance</li></ol><p>此插件在你的编辑器中嵌入了代码的<code>缩略图</code></p><ol start="2"><li>Rainbow Brackets</li></ol><p>这个插件为您的代码添加了漂亮的彩虹色，用于圆括号，方括号和大括号。</p><ol start="3"><li>ADB Idea</li></ol><p>ADB Idea提供了单击快捷方式命令，用于启动，卸载，终止应用程序，撤消权限以及清除应用程序数据。</p><ol start="4"><li>ADB Wifi</li></ol><p>确保你的电脑和手机连接在同一网络上，然后转到<code>“Tools”→“ android”→“ ADB WIFI”→“ ADB USB to WIFI”</code>开始连接，现在您无需USB连接，即可运行应用程序。</p><ol start="5"><li>Material UI Theme</li><li>JSON To Kotlin Class</li><li>Codota</li></ol><p>Codota是一个基于AI的代码补全插件，它使用机器学习数百万个代码段（Java，Javascript，Python等），根据您的上下文建议补全代码。它还使你可以直接嵌入通用代码段，以提高开发技能并减少出错的机会。</p><ol start="8"><li>Name That Color</li></ol><p>最匹配的 material颜色调色板名称</p><ol start="9"><li> Key Promoter X</li></ol><p>这是一个IntelliJ IDE插件，可帮助你在工作时学习基本的快捷方式。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;本文只要介绍Android-studio常用的几款插件（持续更新）。&quot;&gt;&lt;a href=&quot;#本文只要介绍Android-studio常用的几款插件（持续更新）。&quot; class=&quot;headerlink&quot; title=&quot;本文只要介绍Android studio常用的几款插件（持续更新）。&quot;&gt;&lt;/a&gt;本文只要介绍Android studio常用的几款插件（持续更新）。&lt;/h1&gt;</summary>
    
    
    
    <category term="android" scheme="https://blog.popperevan.work/categories/android/"/>
    
    
    <category term="android" scheme="https://blog.popperevan.work/tags/android/"/>
    
    <category term="plugins" scheme="https://blog.popperevan.work/tags/plugins/"/>
    
  </entry>
  
  <entry>
    <title>iTerm2配置和美化</title>
    <link href="https://blog.popperevan.work/posts/d2a06635/"/>
    <id>https://blog.popperevan.work/posts/d2a06635/</id>
    <published>2018-11-19T16:00:00.000Z</published>
    <updated>2021-12-02T14:04:40.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文只要介绍iTerm2在mac-OS上的配置和美化。"><a href="#本文只要介绍iTerm2在mac-OS上的配置和美化。" class="headerlink" title="本文只要介绍iTerm2在mac OS上的配置和美化。"></a>本文只要介绍iTerm2在mac OS上的配置和美化。</h1><span id="more"></span><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>iTerm2</code>是<code>macOS</code>平台上终端的替代方案，功能也更强大</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://iterm2.com/">iTerm2官网</a></p><h3 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h3><pre><code>iTerm2 -&gt; Make ITerm2 Default Term</code></pre><h3 id="设置透明度"><a href="#设置透明度" class="headerlink" title="设置透明度"></a>设置透明度</h3><pre><code>iTerm -&gt; Preferences -&gt; Profiles -&gt; window -&gt; Transparency</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li><p>设置默认shell为zsh</p><ul><li><p>查看系统所有shell列表</p><pre><code>cat /etc/shells</code></pre></li><li><p>查看zsh版本</p><pre><code>zsh --version</code></pre></li><li><p>设置默认 shell 为 zsh，它功能比较多，会好使一些。</p><pre><code>chsh -s /bin/zsh</code></pre></li></ul></li><li><p>安装oh-my-zsh</p><ul><li><p>什么是oh-my-zsh</p><blockquote><p>oh-my-zsh 是一款社区驱动的命令行工具，它基于 zsh 命令行，提供了主题配置，插件机制，大大提高了可玩（用）性。</p></blockquote></li><li><p>下载地址</p><p><a href="https://github.com/ohmyzsh/ohmyzsh">oh-my-zsh</a></p></li><li><p>安装</p><p><strong>以下脚本执行一个</strong>：</p><ul><li><p>wget：</p><pre><code>export REMOTE=https://gitee.com/imirror/ohmyzsh.gitsh -c &quot;$(wget -O- https://cdn.jsdelivr.net/gh/ohmyzsh/ohmyzsh/tools/install.sh)&quot;</code></pre></li><li><p>fetch：</p><pre><code>export REMOTE=https://gitee.com/imirror/ohmyzsh.gitsh -c &quot;$(fetch -o - https://cdn.jsdelivr.net/gh/ohmyzsh/ohmyzsh/tools/install.sh)&quot;</code></pre></li><li><p>curl：</p></li></ul><pre><code>export REMOTE=https://gitee.com/imirror/ohmyzsh.gitsh -c &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ohmyzsh/ohmyzsh/tools/install.sh)&quot;</code></pre></li></ul></li><li><p>配置zsh主题</p><ul><li><p>官方主题</p><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">主题</a></p></li><li><p>vim打开<code>~/.zshrc</code>文件</p><pre><code>vim ~/.zshrc</code></pre></li><li><p>更改ZSH_THEME字段为你所选的主题名称</p></li></ul></li><li><p>更改字体</p></li></ol><pre><code class="iTerm">iTerm -&gt; Preferences -&gt; Profiles -&gt; Text</code></pre><ol start="5"><li>功能增强</li></ol><ul><li>5.1 命令自动补全功能</li></ul><p>​    克隆代码到<code>$ZSH_CUSTOM/plugins</code>（默认位于<code>~/.oh-my-zsh/custom/plugins</code>）</p><pre><code>git clone https://gitee.com/imirror/zsh-autosuggestions.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</code></pre><ul><li>5.1.1执行zshrc文件</li></ul><pre><code>source ~/.zshrc</code></pre><ul><li>5.1.2配置插件</li></ul><p>打开<code>~/.zshrc</code>，找到<code>plugins</code>，追加<code>zsh-autosuggestions</code>。</p><ul><li><p>5.2 语法高亮</p></li><li><p>5.21.克隆代码到<code>$ZSH_CUSTOM/plugins</code>（默认位于<code>~/.oh-my-zsh/custom/plugins</code>）</p></li></ul><pre><code>git clone https://gitee.com/imirror/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</code></pre><ul><li>5.2.2 配置启用插件</li></ul><p>打开<code>~/.zshrc</code>，找到<code>plugins</code>，追加<code>zsh-autosuggestions</code>。</p><ul><li>5.2.3执行zshrc文件</li></ul><pre><code>source ~/.zshrc</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;本文只要介绍iTerm2在mac-OS上的配置和美化。&quot;&gt;&lt;a href=&quot;#本文只要介绍iTerm2在mac-OS上的配置和美化。&quot; class=&quot;headerlink&quot; title=&quot;本文只要介绍iTerm2在mac OS上的配置和美化。&quot;&gt;&lt;/a&gt;本文只要介绍iTerm2在mac OS上的配置和美化。&lt;/h1&gt;</summary>
    
    
    
    <category term="工具" scheme="https://blog.popperevan.work/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="itrem2 zsh" scheme="https://blog.popperevan.work/tags/itrem2-zsh/"/>
    
  </entry>
  
  <entry>
    <title>Typora常用快捷键</title>
    <link href="https://blog.popperevan.work/posts/12a67745/"/>
    <id>https://blog.popperevan.work/posts/12a67745/</id>
    <published>2018-11-19T16:00:00.000Z</published>
    <updated>2021-12-02T14:17:18.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文只要介绍Typora常用快捷键（持续更新）。"><a href="#本文只要介绍Typora常用快捷键（持续更新）。" class="headerlink" title="本文只要介绍Typora常用快捷键（持续更新）。"></a>本文只要介绍Typora常用快捷键（持续更新）。</h1><span id="more"></span><h1 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h1><h2 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h2><p><strong>a markdown editor,markdown reader.</strong></p><h2 id="为什么选择Typora"><a href="#为什么选择Typora" class="headerlink" title="为什么选择Typora"></a>为什么选择Typora</h2><ol><li>轻便简洁</li><li>即时渲染</li><li>可读性强</li><li>学习成本低</li><li>个人习惯：能和开源笔记Joplin结合使用</li><li><del>Free</del>(2021/12/01正式版开始收费)</li></ol><h2 id="与常用markdown语法的区别"><a href="#与常用markdown语法的区别" class="headerlink" title="与常用markdown语法的区别"></a>与常用markdown语法的区别</h2><ol><li>标题、字体等语法支持快捷键</li><li>支持更多的文字格式，可在偏好设置进行设置</li><li>支持更多的对齐方式，如“<center>”进行居中</li></ol><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul><li>加粗 Cmd+B</li><li>标题 <code>Cmd+数字</code> 如一级标题 <code>Cmd+1</code></li><li>插入链接 <code>Cmd+K</code></li><li>代码块 <code>Cmd+option+C</code></li><li>表格 <code>option + Cmd + T</code></li><li>引用 <code>option + Cmd + Q</code></li><li>水平分割线：<code>shift + Cmd + -</code></li><li>斜体 <code>Cmd + I</code></li><li>删除线 <code>control + ~</code></li><li>注释 <code>control + -</code></li><li>显示/隐藏侧边栏 <code>shift + Cmd + L</code></li><li>大纲视图 <code>control + Cmd + 1</code></li><li>文档列表视图 <code>control + Cmd +2</code></li><li>文件树视图：<code>control + Cmd + 3</code></li><li>链接引用 <code>option + Cmd + L</code></li><li>脚注 <code>option + Cmd + R</code></li><li>代码高亮 “`”+回车 选择语言</li><li>下标 H<del>2</del>o</li><li>上标 x^2^</li><li>==高亮==</li><li>目录（TOC）输入[toc] 然后回车，即可创建一个“目录”，TOC从文档中提取所有的标题，其内容将自动更新。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/cf83d2887ea1">typora快捷键使用</a></p><p><a href="https://sspai.com/post/54912">Typora完全使用详解</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;本文只要介绍Typora常用快捷键（持续更新）。&quot;&gt;&lt;a href=&quot;#本文只要介绍Typora常用快捷键（持续更新）。&quot; class=&quot;headerlink&quot; title=&quot;本文只要介绍Typora常用快捷键（持续更新）。&quot;&gt;&lt;/a&gt;本文只要介绍Typora常用快捷键（持续更新）。&lt;/h1&gt;</summary>
    
    
    
    <category term="工具" scheme="https://blog.popperevan.work/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="typora markdown" scheme="https://blog.popperevan.work/tags/typora-markdown/"/>
    
  </entry>
  
</feed>
